#!/usr/bin/env node
import Es from "url";
import vs from "fs";
import rs from "path";
import ur, { argv as Rs, env as we, stdout as ys, exit as wr, cwd as $s } from "node:process";
import { dirname as cr, resolve as Ne, basename as Pe, join as lr } from "node:path";
import { readFileSync as Sr, lstatSync as br, truncateSync as As, writeFileSync as ws, accessSync as Ss } from "node:fs";
import { stripVTControlCharacters as bs } from "node:util";
import Os from "node:os";
import Or from "node:tty";
import { execFileSync as _s } from "node:child_process";
function Ge(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Ye, _r;
function ns() {
  if (_r) return Ye;
  _r = 1;
  function e(o, u) {
    var t = o;
    u.slice(0, -1).forEach(function(n) {
      t = t[n] || {};
    });
    var r = u[u.length - 1];
    return r in t;
  }
  function s(o) {
    return typeof o == "number" || /^0x[0-9a-f]+$/i.test(o) ? !0 : /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(o);
  }
  function i(o, u) {
    return u === "constructor" && typeof o[u] == "function" || u === "__proto__";
  }
  return Ye = function(o, u) {
    u || (u = {});
    var t = {
      bools: {},
      strings: {},
      unknownFn: null
    };
    typeof u.unknown == "function" && (t.unknownFn = u.unknown), typeof u.boolean == "boolean" && u.boolean ? t.allBools = !0 : [].concat(u.boolean).filter(Boolean).forEach(function(T) {
      t.bools[T] = !0;
    });
    var r = {};
    function n(T) {
      return r[T].some(function(B) {
        return t.bools[B];
      });
    }
    Object.keys(u.alias || {}).forEach(function(T) {
      r[T] = [].concat(u.alias[T]), r[T].forEach(function(B) {
        r[B] = [T].concat(r[T].filter(function(M) {
          return B !== M;
        }));
      });
    }), [].concat(u.string).filter(Boolean).forEach(function(T) {
      t.strings[T] = !0, r[T] && [].concat(r[T]).forEach(function(B) {
        t.strings[B] = !0;
      });
    });
    var a = u.default || {}, c = { _: [] };
    function l(T, B) {
      return t.allBools && /^--[^=]+$/.test(B) || t.strings[T] || t.bools[T] || r[T];
    }
    function h(T, B, M) {
      for (var G = T, _ = 0; _ < B.length - 1; _++) {
        var R = B[_];
        if (i(G, R))
          return;
        G[R] === void 0 && (G[R] = {}), (G[R] === Object.prototype || G[R] === Number.prototype || G[R] === String.prototype) && (G[R] = {}), G[R] === Array.prototype && (G[R] = []), G = G[R];
      }
      var I = B[B.length - 1];
      i(G, I) || ((G === Object.prototype || G === Number.prototype || G === String.prototype) && (G = {}), G === Array.prototype && (G = []), G[I] === void 0 || t.bools[I] || typeof G[I] == "boolean" ? G[I] = M : Array.isArray(G[I]) ? G[I].push(M) : G[I] = [G[I], M]);
    }
    function f(T, B, M) {
      if (!(M && t.unknownFn && !l(T, M) && t.unknownFn(M) === !1)) {
        var G = !t.strings[T] && s(B) ? Number(B) : B;
        h(c, T.split("."), G), (r[T] || []).forEach(function(_) {
          h(c, _.split("."), G);
        });
      }
    }
    Object.keys(t.bools).forEach(function(T) {
      f(T, a[T] === void 0 ? !1 : a[T]);
    });
    var g = [];
    o.indexOf("--") !== -1 && (g = o.slice(o.indexOf("--") + 1), o = o.slice(0, o.indexOf("--")));
    for (var b = 0; b < o.length; b++) {
      var O = o[b], p, y;
      if (/^--.+=/.test(O)) {
        var L = O.match(/^--([^=]+)=([\s\S]*)$/);
        p = L[1];
        var E = L[2];
        t.bools[p] && (E = E !== "false"), f(p, E, O);
      } else if (/^--no-.+/.test(O))
        p = O.match(/^--no-(.+)/)[1], f(p, !1, O);
      else if (/^--.+/.test(O))
        p = O.match(/^--(.+)/)[1], y = o[b + 1], y !== void 0 && !/^(-|--)[^-]/.test(y) && !t.bools[p] && !t.allBools && (!r[p] || !n(p)) ? (f(p, y, O), b += 1) : /^(true|false)$/.test(y) ? (f(p, y === "true", O), b += 1) : f(p, t.strings[p] ? "" : !0, O);
      else if (/^-[^-]+/.test(O)) {
        for (var d = O.slice(1, -1).split(""), w = !1, $ = 0; $ < d.length; $++) {
          if (y = O.slice($ + 2), y === "-") {
            f(d[$], y, O);
            continue;
          }
          if (/[A-Za-z]/.test(d[$]) && y[0] === "=") {
            f(d[$], y.slice(1), O), w = !0;
            break;
          }
          if (/[A-Za-z]/.test(d[$]) && /-?\d+(\.\d*)?(e-?\d+)?$/.test(y)) {
            f(d[$], y, O), w = !0;
            break;
          }
          if (d[$ + 1] && d[$ + 1].match(/\W/)) {
            f(d[$], O.slice($ + 2), O), w = !0;
            break;
          } else
            f(d[$], t.strings[d[$]] ? "" : !0, O);
        }
        p = O.slice(-1)[0], !w && p !== "-" && (o[b + 1] && !/^(-|--)[^-]/.test(o[b + 1]) && !t.bools[p] && (!r[p] || !n(p)) ? (f(p, o[b + 1], O), b += 1) : o[b + 1] && /^(true|false)$/.test(o[b + 1]) ? (f(p, o[b + 1] === "true", O), b += 1) : f(p, t.strings[p] ? "" : !0, O));
      } else if ((!t.unknownFn || t.unknownFn(O) !== !1) && c._.push(t.strings._ || !s(O) ? O : Number(O)), u.stopEarly) {
        c._.push.apply(c._, o.slice(b + 1));
        break;
      }
    }
    return Object.keys(a).forEach(function(T) {
      e(c, T.split(".")) || (h(c, T.split("."), a[T]), (r[T] || []).forEach(function(B) {
        h(c, B.split("."), a[T]);
      }));
    }), u["--"] ? c["--"] = g.slice() : g.forEach(function(T) {
      c._.push(T);
    }), c;
  }, Ye;
}
var Ts = ns();
const Is = /* @__PURE__ */ Ge(Ts);
var Ze, Tr;
function xs() {
  if (Tr) return Ze;
  Tr = 1;
  function e(i) {
    return Buffer.from(i, "base64").toString("utf8");
  }
  function s(i) {
    return Buffer.from(i, "utf8").toString("base64");
  }
  return Ze = {
    decodeBase64: e,
    encodeBase64: s
  }, Ze;
}
var Re = {}, Ee = {}, Ir;
function Cs() {
  if (Ir) return Ee;
  Ir = 1, Ee.parse = Ee.decode = o, Ee.stringify = Ee.encode = s, Ee.safe = t, Ee.unsafe = r;
  var e = typeof process < "u" && process.platform === "win32" ? `\r
` : `
`;
  function s(n, a) {
    var c = [], l = "";
    typeof a == "string" ? a = {
      section: a,
      whitespace: !1
    } : (a = a || {}, a.whitespace = a.whitespace === !0);
    var h = a.whitespace ? " = " : "=";
    return Object.keys(n).forEach(function(f, g, b) {
      var O = n[f];
      O && Array.isArray(O) ? O.forEach(function(p) {
        l += t(f + "[]") + h + t(p) + `
`;
      }) : O && typeof O == "object" ? c.push(f) : l += t(f) + h + t(O) + e;
    }), a.section && l.length && (l = "[" + t(a.section) + "]" + e + l), c.forEach(function(f, g, b) {
      var O = i(f).join("\\."), p = (a.section ? a.section + "." : "") + O, y = s(n[f], {
        section: p,
        whitespace: a.whitespace
      });
      l.length && y.length && (l += e), l += y;
    }), l;
  }
  function i(n) {
    return n.replace(/\1/g, "LITERAL\\1LITERAL").replace(/\\\./g, "").split(/\./).map(function(a) {
      return a.replace(/\1/g, "\\.").replace(/\2LITERAL\\1LITERAL\2/g, "");
    });
  }
  function o(n) {
    var a = {}, c = a, l = null, h = /^\[([^\]]*)\]$|^([^=]+)(=(.*))?$/i, f = n.split(/[\r\n]+/g);
    return f.forEach(function(g, b, O) {
      if (!(!g || g.match(/^\s*[;#]/))) {
        var p = g.match(h);
        if (p) {
          if (p[1] !== void 0) {
            if (l = r(p[1]), l === "__proto__") {
              c = {};
              return;
            }
            c = a[l] = a[l] || {};
            return;
          }
          var y = r(p[2]);
          if (y !== "__proto__") {
            var L = p[3] ? r(p[4]) : !0;
            switch (L) {
              case "true":
              case "false":
              case "null":
                L = JSON.parse(L);
            }
            if (y.length > 2 && y.slice(-2) === "[]") {
              if (y = y.substring(0, y.length - 2), y === "__proto__")
                return;
              c[y] ? Array.isArray(c[y]) || (c[y] = [c[y]]) : c[y] = [];
            }
            Array.isArray(c[y]) ? c[y].push(L) : c[y] = L;
          }
        }
      }
    }), Object.keys(a).filter(function(g, b, O) {
      if (!a[g] || typeof a[g] != "object" || Array.isArray(a[g]))
        return !1;
      var p = i(g), y = a, L = p.pop(), E = L.replace(/\\\./g, ".");
      return p.forEach(function(d, w, $) {
        d !== "__proto__" && ((!y[d] || typeof y[d] != "object") && (y[d] = {}), y = y[d]);
      }), y === a && E === L ? !1 : (y[E] = a[g], !0);
    }).forEach(function(g, b, O) {
      delete a[g];
    }), a;
  }
  function u(n) {
    return n.charAt(0) === '"' && n.slice(-1) === '"' || n.charAt(0) === "'" && n.slice(-1) === "'";
  }
  function t(n) {
    return typeof n != "string" || n.match(/[=\r\n]/) || n.match(/^\[/) || n.length > 1 && u(n) || n !== n.trim() ? JSON.stringify(n) : n.replace(/;/g, "\\;").replace(/#/g, "\\#");
  }
  function r(n, a) {
    if (n = (n || "").trim(), u(n)) {
      n.charAt(0) === "'" && (n = n.substr(1, n.length - 2));
      try {
        n = JSON.parse(n);
      } catch {
      }
    } else {
      for (var c = !1, l = "", h = 0, f = n.length; h < f; h++) {
        var g = n.charAt(h);
        if (c)
          "\\;#".indexOf(g) !== -1 ? l += g : l += "\\" + g, c = !1;
        else {
          if (";#".indexOf(g) !== -1)
            break;
          g === "\\" ? c = !0 : l += g;
        }
      }
      return c && (l += "\\"), l.trim();
    }
    return n;
  }
  return Ee;
}
var Qe, xr;
function Ls() {
  if (xr) return Qe;
  xr = 1;
  var e = 1, s = 2;
  function i() {
    return "";
  }
  function o(u, t, r) {
    return u.slice(t, r).replace(/\S/g, " ");
  }
  return Qe = function(u, t) {
    t = t || {};
    for (var r, n, a = !1, c = !1, l = 0, h = "", f = t.whitespace === !1 ? i : o, g = 0; g < u.length; g++) {
      if (r = u[g], n = u[g + 1], !c && r === '"') {
        var b = u[g - 1] === "\\" && u[g - 2] !== "\\";
        b || (a = !a);
      }
      if (!a) {
        if (!c && r + n === "//")
          h += u.slice(l, g), l = g, c = e, g++;
        else if (c === e && r + n === `\r
`) {
          g++, c = !1, h += f(u, l, g), l = g;
          continue;
        } else if (c === e && r === `
`)
          c = !1, h += f(u, l, g), l = g;
        else if (!c && r + n === "/*") {
          h += u.slice(l, g), l = g, c = s, g++;
          continue;
        } else if (c === s && r + n === "*/") {
          g++, c = !1, h += f(u, l, g + 1), l = g + 1;
          continue;
        }
      }
    }
    return h + (c ? f(u.substr(l)) : u.substr(l));
  }, Qe;
}
var Cr;
function Ns() {
  if (Cr) return Re;
  Cr = 1;
  var e = vs, s = Cs(), i = rs, o = Ls(), u = Re.parse = function(r) {
    return /^\s*{/.test(r) ? JSON.parse(o(r)) : s.parse(r);
  }, t = Re.file = function() {
    var r = [].slice.call(arguments).filter(function(c) {
      return c != null;
    });
    for (var n in r)
      if (typeof r[n] != "string")
        return;
    var a = i.join.apply(null, r);
    try {
      return e.readFileSync(a, "utf-8");
    } catch {
      return;
    }
  };
  return Re.json = function() {
    var r = t.apply(null, arguments);
    return r ? u(r) : null;
  }, Re.env = function(r, n) {
    n = n || process.env;
    var a = {}, c = r.length;
    for (var l in n)
      if (l.toLowerCase().indexOf(r.toLowerCase()) === 0) {
        for (var h = l.substring(c).split("__"), f; (f = h.indexOf("")) > -1; )
          h.splice(f, 1);
        var g = a;
        h.forEach(function(O, p) {
          !O || typeof g != "object" || (p === h.length - 1 && (g[O] = n[l]), g[O] === void 0 && (g[O] = {}), g = g[O]);
        });
      }
    return a;
  }, Re.find = function() {
    var r = i.join.apply(null, [].slice.call(arguments));
    function n(a, c) {
      var l = i.join(a, c);
      try {
        return e.statSync(l), l;
      } catch {
        if (i.dirname(a) !== a)
          return n(i.dirname(a), c);
      }
    }
    return n(process.cwd(), r);
  }, Re;
}
var Je = { exports: {} };
var Lr;
function Ps() {
  if (Lr) return Je.exports;
  Lr = 1;
  function e(t) {
    return t instanceof Buffer || t instanceof Date || t instanceof RegExp;
  }
  function s(t) {
    if (t instanceof Buffer) {
      var r = Buffer.alloc ? Buffer.alloc(t.length) : new Buffer(t.length);
      return t.copy(r), r;
    } else {
      if (t instanceof Date)
        return new Date(t.getTime());
      if (t instanceof RegExp)
        return new RegExp(t);
      throw new Error("Unexpected situation");
    }
  }
  function i(t) {
    var r = [];
    return t.forEach(function(n, a) {
      typeof n == "object" && n !== null ? Array.isArray(n) ? r[a] = i(n) : e(n) ? r[a] = s(n) : r[a] = u({}, n) : r[a] = n;
    }), r;
  }
  function o(t, r) {
    return r === "__proto__" ? void 0 : t[r];
  }
  var u = Je.exports = function() {
    if (arguments.length < 1 || typeof arguments[0] != "object")
      return !1;
    if (arguments.length < 2)
      return arguments[0];
    var t = arguments[0], r = Array.prototype.slice.call(arguments, 1), n, a;
    return r.forEach(function(c) {
      typeof c != "object" || c === null || Array.isArray(c) || Object.keys(c).forEach(function(l) {
        if (a = o(t, l), n = o(c, l), n !== t)
          if (typeof n != "object" || n === null) {
            t[l] = n;
            return;
          } else if (Array.isArray(n)) {
            t[l] = i(n);
            return;
          } else if (e(n)) {
            t[l] = s(n);
            return;
          } else if (typeof a != "object" || a === null || Array.isArray(a)) {
            t[l] = u({}, n);
            return;
          } else {
            t[l] = u(a, n);
            return;
          }
      });
    }), t;
  };
  return Je.exports;
}
var et, Nr;
function ss() {
  if (Nr) return et;
  Nr = 1;
  var e = Ns(), s = rs.join, i = Ps(), o = "/etc", u = process.platform === "win32", t = u ? process.env.USERPROFILE : process.env.HOME;
  return et = function(r, n, a, c) {
    if (typeof r != "string")
      throw new Error("rc(name): name *must* be string");
    a || (a = ns()(process.argv.slice(2))), n = (typeof n == "string" ? e.json(n) : n) || {}, c = c || e.parse;
    var l = e.env(r + "_"), h = [n], f = [];
    function g(b) {
      if (!(f.indexOf(b) >= 0)) {
        var O = e.file(b);
        O && (h.push(c(O)), f.push(b));
      }
    }
    return u || [
      s(o, r, "config"),
      s(o, r + "rc")
    ].forEach(g), t && [
      s(t, ".config", r, "config"),
      s(t, ".config", r),
      s(t, "." + r, "config"),
      s(t, "." + r + "rc")
    ].forEach(g), g(e.find("." + r + "rc")), l.config && g(l.config), a.config && g(a.config), i.apply(null, h.concat([
      l,
      a,
      f.length ? { configs: f, config: f[f.length - 1] } : void 0
    ]));
  }, et;
}
var tt, Pr;
function Ds() {
  if (Pr) return tt;
  Pr = 1;
  var e = Es, s = xs(), i = s.decodeBase64, o = s.encodeBase64, u = ":_authToken", t = ":_auth", r = ":username", n = ":_password";
  tt = function() {
    var p, y;
    return arguments.length >= 2 ? (p = arguments[0], y = arguments[1]) : typeof arguments[0] == "string" ? p = arguments[0] : y = arguments[0], y = y || {}, y.npmrc = y.npmrc || ss()("npm", { registry: "https://registry.npmjs.org/" }, {
      config: process.env.npm_config_userconfig || process.env.NPM_CONFIG_USERCONFIG
    }), p = p || y.npmrc.registry, a(p, y) || c(y.npmrc);
  };
  function a(p, y) {
    for (var L = e.parse(p, !1, !0), E; E !== "/" && L.pathname !== E; ) {
      E = L.pathname || "/";
      var d = "//" + L.host + E.replace(/\/$/, ""), w = h(d, y.npmrc);
      if (w)
        return w;
      if (!y.recursive)
        return /\/$/.test(p) ? void 0 : a(e.resolve(p, "."), y);
      L.pathname = e.resolve(l(E), "..") || "/";
    }
  }
  function c(p) {
    if (p._auth) {
      var y = f(p._auth);
      return { token: y, type: "Basic" };
    }
  }
  function l(p) {
    return p[p.length - 1] === "/" ? p : p + "/";
  }
  function h(p, y) {
    var L = g(y[p + u] || y[p + "/" + u]);
    if (L)
      return L;
    var E = y[p + r] || y[p + "/" + r], d = y[p + n] || y[p + "/" + n], w = b(E, d);
    if (w)
      return w;
    var $ = O(y[p + t] || y[p + "/" + t]);
    if ($)
      return $;
  }
  function f(p) {
    return p.replace(/^\$\{?([^}]*)\}?$/, function(y, L) {
      return process.env[L];
    });
  }
  function g(p) {
    if (p) {
      var y = f(p);
      return { token: y, type: "Bearer" };
    }
  }
  function b(p, y) {
    if (!(!p || !y)) {
      var L = i(f(y)), E = o(p + ":" + L);
      return {
        token: E,
        type: "Basic",
        password: L,
        username: p
      };
    }
  }
  function O(p) {
    if (p) {
      var y = f(p);
      return { token: y, type: "Basic" };
    }
  }
  return tt;
}
var qs = Ds();
const rt = /* @__PURE__ */ Ge(qs);
var Hs = ss();
const js = /* @__PURE__ */ Ge(Hs);
var Le = { exports: {} }, nt, Dr;
function Be() {
  if (Dr) return nt;
  Dr = 1;
  const e = "2.0.0", s = 256, i = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
  9007199254740991;
  return nt = {
    SEMVER_SPEC_VERSION: e,
    MAX_LENGTH: s,
    MAX_SAFE_INTEGER: i,
    MAX_SAFE_COMPONENT_LENGTH: 16
  }, nt;
}
var st, qr;
function Me() {
  return qr || (qr = 1, st = typeof process == "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...s) => console.error("SEMVER", ...s) : () => {
  }), st;
}
var Hr;
function be() {
  return Hr || (Hr = 1, function(e, s) {
    const { MAX_SAFE_COMPONENT_LENGTH: i } = Be(), o = Me();
    s = e.exports = {};
    const u = s.re = [], t = s.src = [], r = s.t = {};
    let n = 0;
    const a = (c, l, h) => {
      const f = n++;
      o(c, f, l), r[c] = f, t[f] = l, u[f] = new RegExp(l, h ? "g" : void 0);
    };
    a("NUMERICIDENTIFIER", "0|[1-9]\\d*"), a("NUMERICIDENTIFIERLOOSE", "[0-9]+"), a("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), a("MAINVERSION", `(${t[r.NUMERICIDENTIFIER]})\\.(${t[r.NUMERICIDENTIFIER]})\\.(${t[r.NUMERICIDENTIFIER]})`), a("MAINVERSIONLOOSE", `(${t[r.NUMERICIDENTIFIERLOOSE]})\\.(${t[r.NUMERICIDENTIFIERLOOSE]})\\.(${t[r.NUMERICIDENTIFIERLOOSE]})`), a("PRERELEASEIDENTIFIER", `(?:${t[r.NUMERICIDENTIFIER]}|${t[r.NONNUMERICIDENTIFIER]})`), a("PRERELEASEIDENTIFIERLOOSE", `(?:${t[r.NUMERICIDENTIFIERLOOSE]}|${t[r.NONNUMERICIDENTIFIER]})`), a("PRERELEASE", `(?:-(${t[r.PRERELEASEIDENTIFIER]}(?:\\.${t[r.PRERELEASEIDENTIFIER]})*))`), a("PRERELEASELOOSE", `(?:-?(${t[r.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${t[r.PRERELEASEIDENTIFIERLOOSE]})*))`), a("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), a("BUILD", `(?:\\+(${t[r.BUILDIDENTIFIER]}(?:\\.${t[r.BUILDIDENTIFIER]})*))`), a("FULLPLAIN", `v?${t[r.MAINVERSION]}${t[r.PRERELEASE]}?${t[r.BUILD]}?`), a("FULL", `^${t[r.FULLPLAIN]}$`), a("LOOSEPLAIN", `[v=\\s]*${t[r.MAINVERSIONLOOSE]}${t[r.PRERELEASELOOSE]}?${t[r.BUILD]}?`), a("LOOSE", `^${t[r.LOOSEPLAIN]}$`), a("GTLT", "((?:<|>)?=?)"), a("XRANGEIDENTIFIERLOOSE", `${t[r.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), a("XRANGEIDENTIFIER", `${t[r.NUMERICIDENTIFIER]}|x|X|\\*`), a("XRANGEPLAIN", `[v=\\s]*(${t[r.XRANGEIDENTIFIER]})(?:\\.(${t[r.XRANGEIDENTIFIER]})(?:\\.(${t[r.XRANGEIDENTIFIER]})(?:${t[r.PRERELEASE]})?${t[r.BUILD]}?)?)?`), a("XRANGEPLAINLOOSE", `[v=\\s]*(${t[r.XRANGEIDENTIFIERLOOSE]})(?:\\.(${t[r.XRANGEIDENTIFIERLOOSE]})(?:\\.(${t[r.XRANGEIDENTIFIERLOOSE]})(?:${t[r.PRERELEASELOOSE]})?${t[r.BUILD]}?)?)?`), a("XRANGE", `^${t[r.GTLT]}\\s*${t[r.XRANGEPLAIN]}$`), a("XRANGELOOSE", `^${t[r.GTLT]}\\s*${t[r.XRANGEPLAINLOOSE]}$`), a("COERCE", `(^|[^\\d])(\\d{1,${i}})(?:\\.(\\d{1,${i}}))?(?:\\.(\\d{1,${i}}))?(?:$|[^\\d])`), a("COERCERTL", t[r.COERCE], !0), a("LONETILDE", "(?:~>?)"), a("TILDETRIM", `(\\s*)${t[r.LONETILDE]}\\s+`, !0), s.tildeTrimReplace = "$1~", a("TILDE", `^${t[r.LONETILDE]}${t[r.XRANGEPLAIN]}$`), a("TILDELOOSE", `^${t[r.LONETILDE]}${t[r.XRANGEPLAINLOOSE]}$`), a("LONECARET", "(?:\\^)"), a("CARETTRIM", `(\\s*)${t[r.LONECARET]}\\s+`, !0), s.caretTrimReplace = "$1^", a("CARET", `^${t[r.LONECARET]}${t[r.XRANGEPLAIN]}$`), a("CARETLOOSE", `^${t[r.LONECARET]}${t[r.XRANGEPLAINLOOSE]}$`), a("COMPARATORLOOSE", `^${t[r.GTLT]}\\s*(${t[r.LOOSEPLAIN]})$|^$`), a("COMPARATOR", `^${t[r.GTLT]}\\s*(${t[r.FULLPLAIN]})$|^$`), a("COMPARATORTRIM", `(\\s*)${t[r.GTLT]}\\s*(${t[r.LOOSEPLAIN]}|${t[r.XRANGEPLAIN]})`, !0), s.comparatorTrimReplace = "$1$2$3", a("HYPHENRANGE", `^\\s*(${t[r.XRANGEPLAIN]})\\s+-\\s+(${t[r.XRANGEPLAIN]})\\s*$`), a("HYPHENRANGELOOSE", `^\\s*(${t[r.XRANGEPLAINLOOSE]})\\s+-\\s+(${t[r.XRANGEPLAINLOOSE]})\\s*$`), a("STAR", "(<|>)?=?\\s*\\*"), a("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), a("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }(Le, Le.exports)), Le.exports;
}
var it, jr;
function Fe() {
  if (jr) return it;
  jr = 1;
  const e = ["includePrerelease", "loose", "rtl"];
  return it = (i) => i ? typeof i != "object" ? { loose: !0 } : e.filter((o) => i[o]).reduce((o, u) => (o[u] = !0, o), {}) : {}, it;
}
var ot, Gr;
function is() {
  if (Gr) return ot;
  Gr = 1;
  const e = /^[0-9]+$/, s = (o, u) => {
    const t = e.test(o), r = e.test(u);
    return t && r && (o = +o, u = +u), o === u ? 0 : t && !r ? -1 : r && !t ? 1 : o < u ? -1 : 1;
  };
  return ot = {
    compareIdentifiers: s,
    rcompareIdentifiers: (o, u) => s(u, o)
  }, ot;
}
var at, Br;
function ae() {
  if (Br) return at;
  Br = 1;
  const e = Me(), { MAX_LENGTH: s, MAX_SAFE_INTEGER: i } = Be(), { re: o, t: u } = be(), t = Fe(), { compareIdentifiers: r } = is();
  class n {
    constructor(c, l) {
      if (l = t(l), c instanceof n) {
        if (c.loose === !!l.loose && c.includePrerelease === !!l.includePrerelease)
          return c;
        c = c.version;
      } else if (typeof c != "string")
        throw new TypeError(`Invalid Version: ${c}`);
      if (c.length > s)
        throw new TypeError(
          `version is longer than ${s} characters`
        );
      e("SemVer", c, l), this.options = l, this.loose = !!l.loose, this.includePrerelease = !!l.includePrerelease;
      const h = c.trim().match(l.loose ? o[u.LOOSE] : o[u.FULL]);
      if (!h)
        throw new TypeError(`Invalid Version: ${c}`);
      if (this.raw = c, this.major = +h[1], this.minor = +h[2], this.patch = +h[3], this.major > i || this.major < 0)
        throw new TypeError("Invalid major version");
      if (this.minor > i || this.minor < 0)
        throw new TypeError("Invalid minor version");
      if (this.patch > i || this.patch < 0)
        throw new TypeError("Invalid patch version");
      h[4] ? this.prerelease = h[4].split(".").map((f) => {
        if (/^[0-9]+$/.test(f)) {
          const g = +f;
          if (g >= 0 && g < i)
            return g;
        }
        return f;
      }) : this.prerelease = [], this.build = h[5] ? h[5].split(".") : [], this.format();
    }
    format() {
      return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
    }
    toString() {
      return this.version;
    }
    compare(c) {
      if (e("SemVer.compare", this.version, this.options, c), !(c instanceof n)) {
        if (typeof c == "string" && c === this.version)
          return 0;
        c = new n(c, this.options);
      }
      return c.version === this.version ? 0 : this.compareMain(c) || this.comparePre(c);
    }
    compareMain(c) {
      return c instanceof n || (c = new n(c, this.options)), r(this.major, c.major) || r(this.minor, c.minor) || r(this.patch, c.patch);
    }
    comparePre(c) {
      if (c instanceof n || (c = new n(c, this.options)), this.prerelease.length && !c.prerelease.length)
        return -1;
      if (!this.prerelease.length && c.prerelease.length)
        return 1;
      if (!this.prerelease.length && !c.prerelease.length)
        return 0;
      let l = 0;
      do {
        const h = this.prerelease[l], f = c.prerelease[l];
        if (e("prerelease compare", l, h, f), h === void 0 && f === void 0)
          return 0;
        if (f === void 0)
          return 1;
        if (h === void 0)
          return -1;
        if (h === f)
          continue;
        return r(h, f);
      } while (++l);
    }
    compareBuild(c) {
      c instanceof n || (c = new n(c, this.options));
      let l = 0;
      do {
        const h = this.build[l], f = c.build[l];
        if (e("prerelease compare", l, h, f), h === void 0 && f === void 0)
          return 0;
        if (f === void 0)
          return 1;
        if (h === void 0)
          return -1;
        if (h === f)
          continue;
        return r(h, f);
      } while (++l);
    }
    // preminor will bump the version up to the next minor release, and immediately
    // down to pre-release. premajor and prepatch work the same way.
    inc(c, l) {
      switch (c) {
        case "premajor":
          this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", l);
          break;
        case "preminor":
          this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", l);
          break;
        case "prepatch":
          this.prerelease.length = 0, this.inc("patch", l), this.inc("pre", l);
          break;
        // If the input is a non-prerelease version, this acts the same as
        // prepatch.
        case "prerelease":
          this.prerelease.length === 0 && this.inc("patch", l), this.inc("pre", l);
          break;
        case "major":
          (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
          break;
        case "minor":
          (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
          break;
        case "patch":
          this.prerelease.length === 0 && this.patch++, this.prerelease = [];
          break;
        // This probably shouldn't be used publicly.
        // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
        case "pre":
          if (this.prerelease.length === 0)
            this.prerelease = [0];
          else {
            let h = this.prerelease.length;
            for (; --h >= 0; )
              typeof this.prerelease[h] == "number" && (this.prerelease[h]++, h = -2);
            h === -1 && this.prerelease.push(0);
          }
          l && (r(this.prerelease[0], l) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = [l, 0]) : this.prerelease = [l, 0]);
          break;
        default:
          throw new Error(`invalid increment argument: ${c}`);
      }
      return this.format(), this.raw = this.version, this;
    }
  }
  return at = n, at;
}
var ut, Mr;
function Oe() {
  if (Mr) return ut;
  Mr = 1;
  const { MAX_LENGTH: e } = Be(), { re: s, t: i } = be(), o = ae(), u = Fe();
  return ut = (r, n) => {
    if (n = u(n), r instanceof o)
      return r;
    if (typeof r != "string" || r.length > e || !(n.loose ? s[i.LOOSE] : s[i.FULL]).test(r))
      return null;
    try {
      return new o(r, n);
    } catch {
      return null;
    }
  }, ut;
}
var ct, Fr;
function Gs() {
  if (Fr) return ct;
  Fr = 1;
  const e = Oe();
  return ct = (i, o) => {
    const u = e(i, o);
    return u ? u.version : null;
  }, ct;
}
var lt, Ur;
function Bs() {
  if (Ur) return lt;
  Ur = 1;
  const e = Oe();
  return lt = (i, o) => {
    const u = e(i.trim().replace(/^[=v]+/, ""), o);
    return u ? u.version : null;
  }, lt;
}
var ft, kr;
function Ms() {
  if (kr) return ft;
  kr = 1;
  const e = ae();
  return ft = (i, o, u, t) => {
    typeof u == "string" && (t = u, u = void 0);
    try {
      return new e(
        i instanceof e ? i.version : i,
        u
      ).inc(o, t).version;
    } catch {
      return null;
    }
  }, ft;
}
var ht, Vr;
function he() {
  if (Vr) return ht;
  Vr = 1;
  const e = ae();
  return ht = (i, o, u) => new e(i, u).compare(new e(o, u)), ht;
}
var pt, Xr;
function fr() {
  if (Xr) return pt;
  Xr = 1;
  const e = he();
  return pt = (i, o, u) => e(i, o, u) === 0, pt;
}
var dt, Kr;
function Fs() {
  if (Kr) return dt;
  Kr = 1;
  const e = Oe(), s = fr();
  return dt = (o, u) => {
    if (s(o, u))
      return null;
    {
      const t = e(o), r = e(u), n = t.prerelease.length || r.prerelease.length, a = n ? "pre" : "", c = n ? "prerelease" : "";
      for (const l in t)
        if ((l === "major" || l === "minor" || l === "patch") && t[l] !== r[l])
          return a + l;
      return c;
    }
  }, dt;
}
var gt, zr;
function Us() {
  if (zr) return gt;
  zr = 1;
  const e = ae();
  return gt = (i, o) => new e(i, o).major, gt;
}
var mt, Wr;
function ks() {
  if (Wr) return mt;
  Wr = 1;
  const e = ae();
  return mt = (i, o) => new e(i, o).minor, mt;
}
var Et, Yr;
function Vs() {
  if (Yr) return Et;
  Yr = 1;
  const e = ae();
  return Et = (i, o) => new e(i, o).patch, Et;
}
var vt, Zr;
function Xs() {
  if (Zr) return vt;
  Zr = 1;
  const e = Oe();
  return vt = (i, o) => {
    const u = e(i, o);
    return u && u.prerelease.length ? u.prerelease : null;
  }, vt;
}
var Rt, Qr;
function Ks() {
  if (Qr) return Rt;
  Qr = 1;
  const e = he();
  return Rt = (i, o, u) => e(o, i, u), Rt;
}
var yt, Jr;
function zs() {
  if (Jr) return yt;
  Jr = 1;
  const e = he();
  return yt = (i, o) => e(i, o, !0), yt;
}
var $t, en;
function hr() {
  if (en) return $t;
  en = 1;
  const e = ae();
  return $t = (i, o, u) => {
    const t = new e(i, u), r = new e(o, u);
    return t.compare(r) || t.compareBuild(r);
  }, $t;
}
var At, tn;
function Ws() {
  if (tn) return At;
  tn = 1;
  const e = hr();
  return At = (i, o) => i.sort((u, t) => e(u, t, o)), At;
}
var wt, rn;
function Ys() {
  if (rn) return wt;
  rn = 1;
  const e = hr();
  return wt = (i, o) => i.sort((u, t) => e(t, u, o)), wt;
}
var St, nn;
function Ue() {
  if (nn) return St;
  nn = 1;
  const e = he();
  return St = (i, o, u) => e(i, o, u) > 0, St;
}
var bt, sn;
function pr() {
  if (sn) return bt;
  sn = 1;
  const e = he();
  return bt = (i, o, u) => e(i, o, u) < 0, bt;
}
var Ot, on;
function os() {
  if (on) return Ot;
  on = 1;
  const e = he();
  return Ot = (i, o, u) => e(i, o, u) !== 0, Ot;
}
var _t, an;
function dr() {
  if (an) return _t;
  an = 1;
  const e = he();
  return _t = (i, o, u) => e(i, o, u) >= 0, _t;
}
var Tt, un;
function gr() {
  if (un) return Tt;
  un = 1;
  const e = he();
  return Tt = (i, o, u) => e(i, o, u) <= 0, Tt;
}
var It, cn;
function as() {
  if (cn) return It;
  cn = 1;
  const e = fr(), s = os(), i = Ue(), o = dr(), u = pr(), t = gr();
  return It = (n, a, c, l) => {
    switch (a) {
      case "===":
        return typeof n == "object" && (n = n.version), typeof c == "object" && (c = c.version), n === c;
      case "!==":
        return typeof n == "object" && (n = n.version), typeof c == "object" && (c = c.version), n !== c;
      case "":
      case "=":
      case "==":
        return e(n, c, l);
      case "!=":
        return s(n, c, l);
      case ">":
        return i(n, c, l);
      case ">=":
        return o(n, c, l);
      case "<":
        return u(n, c, l);
      case "<=":
        return t(n, c, l);
      default:
        throw new TypeError(`Invalid operator: ${a}`);
    }
  }, It;
}
var xt, ln;
function Zs() {
  if (ln) return xt;
  ln = 1;
  const e = ae(), s = Oe(), { re: i, t: o } = be();
  return xt = (t, r) => {
    if (t instanceof e)
      return t;
    if (typeof t == "number" && (t = String(t)), typeof t != "string")
      return null;
    r = r || {};
    let n = null;
    if (!r.rtl)
      n = t.match(i[o.COERCE]);
    else {
      let a;
      for (; (a = i[o.COERCERTL].exec(t)) && (!n || n.index + n[0].length !== t.length); )
        (!n || a.index + a[0].length !== n.index + n[0].length) && (n = a), i[o.COERCERTL].lastIndex = a.index + a[1].length + a[2].length;
      i[o.COERCERTL].lastIndex = -1;
    }
    return n === null ? null : s(`${n[2]}.${n[3] || "0"}.${n[4] || "0"}`, r);
  }, xt;
}
var Ct, fn;
function Qs() {
  return fn || (fn = 1, Ct = function(e) {
    e.prototype[Symbol.iterator] = function* () {
      for (let s = this.head; s; s = s.next)
        yield s.value;
    };
  }), Ct;
}
var Lt, hn;
function Js() {
  if (hn) return Lt;
  hn = 1, Lt = e, e.Node = u, e.create = e;
  function e(t) {
    var r = this;
    if (r instanceof e || (r = new e()), r.tail = null, r.head = null, r.length = 0, t && typeof t.forEach == "function")
      t.forEach(function(c) {
        r.push(c);
      });
    else if (arguments.length > 0)
      for (var n = 0, a = arguments.length; n < a; n++)
        r.push(arguments[n]);
    return r;
  }
  e.prototype.removeNode = function(t) {
    if (t.list !== this)
      throw new Error("removing node which does not belong to this list");
    var r = t.next, n = t.prev;
    return r && (r.prev = n), n && (n.next = r), t === this.head && (this.head = r), t === this.tail && (this.tail = n), t.list.length--, t.next = null, t.prev = null, t.list = null, r;
  }, e.prototype.unshiftNode = function(t) {
    if (t !== this.head) {
      t.list && t.list.removeNode(t);
      var r = this.head;
      t.list = this, t.next = r, r && (r.prev = t), this.head = t, this.tail || (this.tail = t), this.length++;
    }
  }, e.prototype.pushNode = function(t) {
    if (t !== this.tail) {
      t.list && t.list.removeNode(t);
      var r = this.tail;
      t.list = this, t.prev = r, r && (r.next = t), this.tail = t, this.head || (this.head = t), this.length++;
    }
  }, e.prototype.push = function() {
    for (var t = 0, r = arguments.length; t < r; t++)
      i(this, arguments[t]);
    return this.length;
  }, e.prototype.unshift = function() {
    for (var t = 0, r = arguments.length; t < r; t++)
      o(this, arguments[t]);
    return this.length;
  }, e.prototype.pop = function() {
    if (this.tail) {
      var t = this.tail.value;
      return this.tail = this.tail.prev, this.tail ? this.tail.next = null : this.head = null, this.length--, t;
    }
  }, e.prototype.shift = function() {
    if (this.head) {
      var t = this.head.value;
      return this.head = this.head.next, this.head ? this.head.prev = null : this.tail = null, this.length--, t;
    }
  }, e.prototype.forEach = function(t, r) {
    r = r || this;
    for (var n = this.head, a = 0; n !== null; a++)
      t.call(r, n.value, a, this), n = n.next;
  }, e.prototype.forEachReverse = function(t, r) {
    r = r || this;
    for (var n = this.tail, a = this.length - 1; n !== null; a--)
      t.call(r, n.value, a, this), n = n.prev;
  }, e.prototype.get = function(t) {
    for (var r = 0, n = this.head; n !== null && r < t; r++)
      n = n.next;
    if (r === t && n !== null)
      return n.value;
  }, e.prototype.getReverse = function(t) {
    for (var r = 0, n = this.tail; n !== null && r < t; r++)
      n = n.prev;
    if (r === t && n !== null)
      return n.value;
  }, e.prototype.map = function(t, r) {
    r = r || this;
    for (var n = new e(), a = this.head; a !== null; )
      n.push(t.call(r, a.value, this)), a = a.next;
    return n;
  }, e.prototype.mapReverse = function(t, r) {
    r = r || this;
    for (var n = new e(), a = this.tail; a !== null; )
      n.push(t.call(r, a.value, this)), a = a.prev;
    return n;
  }, e.prototype.reduce = function(t, r) {
    var n, a = this.head;
    if (arguments.length > 1)
      n = r;
    else if (this.head)
      a = this.head.next, n = this.head.value;
    else
      throw new TypeError("Reduce of empty list with no initial value");
    for (var c = 0; a !== null; c++)
      n = t(n, a.value, c), a = a.next;
    return n;
  }, e.prototype.reduceReverse = function(t, r) {
    var n, a = this.tail;
    if (arguments.length > 1)
      n = r;
    else if (this.tail)
      a = this.tail.prev, n = this.tail.value;
    else
      throw new TypeError("Reduce of empty list with no initial value");
    for (var c = this.length - 1; a !== null; c--)
      n = t(n, a.value, c), a = a.prev;
    return n;
  }, e.prototype.toArray = function() {
    for (var t = new Array(this.length), r = 0, n = this.head; n !== null; r++)
      t[r] = n.value, n = n.next;
    return t;
  }, e.prototype.toArrayReverse = function() {
    for (var t = new Array(this.length), r = 0, n = this.tail; n !== null; r++)
      t[r] = n.value, n = n.prev;
    return t;
  }, e.prototype.slice = function(t, r) {
    r = r || this.length, r < 0 && (r += this.length), t = t || 0, t < 0 && (t += this.length);
    var n = new e();
    if (r < t || r < 0)
      return n;
    t < 0 && (t = 0), r > this.length && (r = this.length);
    for (var a = 0, c = this.head; c !== null && a < t; a++)
      c = c.next;
    for (; c !== null && a < r; a++, c = c.next)
      n.push(c.value);
    return n;
  }, e.prototype.sliceReverse = function(t, r) {
    r = r || this.length, r < 0 && (r += this.length), t = t || 0, t < 0 && (t += this.length);
    var n = new e();
    if (r < t || r < 0)
      return n;
    t < 0 && (t = 0), r > this.length && (r = this.length);
    for (var a = this.length, c = this.tail; c !== null && a > r; a--)
      c = c.prev;
    for (; c !== null && a > t; a--, c = c.prev)
      n.push(c.value);
    return n;
  }, e.prototype.splice = function(t, r, ...n) {
    t > this.length && (t = this.length - 1), t < 0 && (t = this.length + t);
    for (var a = 0, c = this.head; c !== null && a < t; a++)
      c = c.next;
    for (var l = [], a = 0; c && a < r; a++)
      l.push(c.value), c = this.removeNode(c);
    c === null && (c = this.tail), c !== this.head && c !== this.tail && (c = c.prev);
    for (var a = 0; a < n.length; a++)
      c = s(this, c, n[a]);
    return l;
  }, e.prototype.reverse = function() {
    for (var t = this.head, r = this.tail, n = t; n !== null; n = n.prev) {
      var a = n.prev;
      n.prev = n.next, n.next = a;
    }
    return this.head = r, this.tail = t, this;
  };
  function s(t, r, n) {
    var a = r === t.head ? new u(n, null, r, t) : new u(n, r, r.next, t);
    return a.next === null && (t.tail = a), a.prev === null && (t.head = a), t.length++, a;
  }
  function i(t, r) {
    t.tail = new u(r, t.tail, null, t), t.head || (t.head = t.tail), t.length++;
  }
  function o(t, r) {
    t.head = new u(r, null, t.head, t), t.tail || (t.tail = t.head), t.length++;
  }
  function u(t, r, n, a) {
    if (!(this instanceof u))
      return new u(t, r, n, a);
    this.list = a, this.value = t, r ? (r.next = this, this.prev = r) : this.prev = null, n ? (n.prev = this, this.next = n) : this.next = null;
  }
  try {
    Qs()(e);
  } catch {
  }
  return Lt;
}
var Nt, pn;
function ei() {
  if (pn) return Nt;
  pn = 1;
  const e = Js(), s = Symbol("max"), i = Symbol("length"), o = Symbol("lengthCalculator"), u = Symbol("allowStale"), t = Symbol("maxAge"), r = Symbol("dispose"), n = Symbol("noDisposeOnSet"), a = Symbol("lruList"), c = Symbol("cache"), l = Symbol("updateAgeOnGet"), h = () => 1;
  class f {
    constructor(d) {
      if (typeof d == "number" && (d = { max: d }), d || (d = {}), d.max && (typeof d.max != "number" || d.max < 0))
        throw new TypeError("max must be a non-negative number");
      this[s] = d.max || 1 / 0;
      const w = d.length || h;
      if (this[o] = typeof w != "function" ? h : w, this[u] = d.stale || !1, d.maxAge && typeof d.maxAge != "number")
        throw new TypeError("maxAge must be a number");
      this[t] = d.maxAge || 0, this[r] = d.dispose, this[n] = d.noDisposeOnSet || !1, this[l] = d.updateAgeOnGet || !1, this.reset();
    }
    // resize the cache when the max changes.
    set max(d) {
      if (typeof d != "number" || d < 0)
        throw new TypeError("max must be a non-negative number");
      this[s] = d || 1 / 0, O(this);
    }
    get max() {
      return this[s];
    }
    set allowStale(d) {
      this[u] = !!d;
    }
    get allowStale() {
      return this[u];
    }
    set maxAge(d) {
      if (typeof d != "number")
        throw new TypeError("maxAge must be a non-negative number");
      this[t] = d, O(this);
    }
    get maxAge() {
      return this[t];
    }
    // resize the cache when the lengthCalculator changes.
    set lengthCalculator(d) {
      typeof d != "function" && (d = h), d !== this[o] && (this[o] = d, this[i] = 0, this[a].forEach((w) => {
        w.length = this[o](w.value, w.key), this[i] += w.length;
      })), O(this);
    }
    get lengthCalculator() {
      return this[o];
    }
    get length() {
      return this[i];
    }
    get itemCount() {
      return this[a].length;
    }
    rforEach(d, w) {
      w = w || this;
      for (let $ = this[a].tail; $ !== null; ) {
        const T = $.prev;
        L(this, d, $, w), $ = T;
      }
    }
    forEach(d, w) {
      w = w || this;
      for (let $ = this[a].head; $ !== null; ) {
        const T = $.next;
        L(this, d, $, w), $ = T;
      }
    }
    keys() {
      return this[a].toArray().map((d) => d.key);
    }
    values() {
      return this[a].toArray().map((d) => d.value);
    }
    reset() {
      this[r] && this[a] && this[a].length && this[a].forEach((d) => this[r](d.key, d.value)), this[c] = /* @__PURE__ */ new Map(), this[a] = new e(), this[i] = 0;
    }
    dump() {
      return this[a].map((d) => b(this, d) ? !1 : {
        k: d.key,
        v: d.value,
        e: d.now + (d.maxAge || 0)
      }).toArray().filter((d) => d);
    }
    dumpLru() {
      return this[a];
    }
    set(d, w, $) {
      if ($ = $ || this[t], $ && typeof $ != "number")
        throw new TypeError("maxAge must be a number");
      const T = $ ? Date.now() : 0, B = this[o](w, d);
      if (this[c].has(d)) {
        if (B > this[s])
          return p(this, this[c].get(d)), !1;
        const _ = this[c].get(d).value;
        return this[r] && (this[n] || this[r](d, _.value)), _.now = T, _.maxAge = $, _.value = w, this[i] += B - _.length, _.length = B, this.get(d), O(this), !0;
      }
      const M = new y(d, w, B, T, $);
      return M.length > this[s] ? (this[r] && this[r](d, w), !1) : (this[i] += M.length, this[a].unshift(M), this[c].set(d, this[a].head), O(this), !0);
    }
    has(d) {
      if (!this[c].has(d)) return !1;
      const w = this[c].get(d).value;
      return !b(this, w);
    }
    get(d) {
      return g(this, d, !0);
    }
    peek(d) {
      return g(this, d, !1);
    }
    pop() {
      const d = this[a].tail;
      return d ? (p(this, d), d.value) : null;
    }
    del(d) {
      p(this, this[c].get(d));
    }
    load(d) {
      this.reset();
      const w = Date.now();
      for (let $ = d.length - 1; $ >= 0; $--) {
        const T = d[$], B = T.e || 0;
        if (B === 0)
          this.set(T.k, T.v);
        else {
          const M = B - w;
          M > 0 && this.set(T.k, T.v, M);
        }
      }
    }
    prune() {
      this[c].forEach((d, w) => g(this, w, !1));
    }
  }
  const g = (E, d, w) => {
    const $ = E[c].get(d);
    if ($) {
      const T = $.value;
      if (b(E, T)) {
        if (p(E, $), !E[u])
          return;
      } else
        w && (E[l] && ($.value.now = Date.now()), E[a].unshiftNode($));
      return T.value;
    }
  }, b = (E, d) => {
    if (!d || !d.maxAge && !E[t])
      return !1;
    const w = Date.now() - d.now;
    return d.maxAge ? w > d.maxAge : E[t] && w > E[t];
  }, O = (E) => {
    if (E[i] > E[s])
      for (let d = E[a].tail; E[i] > E[s] && d !== null; ) {
        const w = d.prev;
        p(E, d), d = w;
      }
  }, p = (E, d) => {
    if (d) {
      const w = d.value;
      E[r] && E[r](w.key, w.value), E[i] -= w.length, E[c].delete(w.key), E[a].removeNode(d);
    }
  };
  class y {
    constructor(d, w, $, T, B) {
      this.key = d, this.value = w, this.length = $, this.now = T, this.maxAge = B || 0;
    }
  }
  const L = (E, d, w, $) => {
    let T = w.value;
    b(E, T) && (p(E, w), E[u] || (T = void 0)), T && d.call($, T.value, T.key, E);
  };
  return Nt = f, Nt;
}
var Pt, dn;
function pe() {
  if (dn) return Pt;
  dn = 1;
  class e {
    constructor(R, I) {
      if (I = o(I), R instanceof e)
        return R.loose === !!I.loose && R.includePrerelease === !!I.includePrerelease ? R : new e(R.raw, I);
      if (R instanceof u)
        return this.raw = R.value, this.set = [[R]], this.format(), this;
      if (this.options = I, this.loose = !!I.loose, this.includePrerelease = !!I.includePrerelease, this.raw = R, this.set = R.split("||").map((q) => this.parseRange(q.trim())).filter((q) => q.length), !this.set.length)
        throw new TypeError(`Invalid SemVer Range: ${R}`);
      if (this.set.length > 1) {
        const q = this.set[0];
        if (this.set = this.set.filter((j) => !f(j[0])), this.set.length === 0)
          this.set = [q];
        else if (this.set.length > 1) {
          for (const j of this.set)
            if (j.length === 1 && g(j[0])) {
              this.set = [j];
              break;
            }
        }
      }
      this.format();
    }
    format() {
      return this.range = this.set.map((R) => R.join(" ").trim()).join("||").trim(), this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(R) {
      R = R.trim();
      const q = `parseRange:${Object.keys(this.options).join(",")}:${R}`, j = i.get(q);
      if (j)
        return j;
      const A = this.options.loose, x = A ? n[a.HYPHENRANGELOOSE] : n[a.HYPHENRANGE];
      R = R.replace(x, M(this.options.includePrerelease)), t("hyphen replace", R), R = R.replace(n[a.COMPARATORTRIM], c), t("comparator trim", R), R = R.replace(n[a.TILDETRIM], l), R = R.replace(n[a.CARETTRIM], h), R = R.split(/\s+/).join(" ");
      let D = R.split(" ").map((U) => O(U, this.options)).join(" ").split(/\s+/).map((U) => B(U, this.options));
      A && (D = D.filter((U) => (t("loose invalid filter", U, this.options), !!U.match(n[a.COMPARATORLOOSE])))), t("range list", D);
      const N = /* @__PURE__ */ new Map(), m = D.map((U) => new u(U, this.options));
      for (const U of m) {
        if (f(U))
          return [U];
        N.set(U.value, U);
      }
      N.size > 1 && N.has("") && N.delete("");
      const k = [...N.values()];
      return i.set(q, k), k;
    }
    intersects(R, I) {
      if (!(R instanceof e))
        throw new TypeError("a Range is required");
      return this.set.some((q) => b(q, I) && R.set.some((j) => b(j, I) && q.every((A) => j.every((x) => A.intersects(x, I)))));
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test(R) {
      if (!R)
        return !1;
      if (typeof R == "string")
        try {
          R = new r(R, this.options);
        } catch {
          return !1;
        }
      for (let I = 0; I < this.set.length; I++)
        if (G(this.set[I], R, this.options))
          return !0;
      return !1;
    }
  }
  Pt = e;
  const s = ei(), i = new s({ max: 1e3 }), o = Fe(), u = ke(), t = Me(), r = ae(), {
    re: n,
    t: a,
    comparatorTrimReplace: c,
    tildeTrimReplace: l,
    caretTrimReplace: h
  } = be(), f = (_) => _.value === "<0.0.0-0", g = (_) => _.value === "", b = (_, R) => {
    let I = !0;
    const q = _.slice();
    let j = q.pop();
    for (; I && q.length; )
      I = q.every((A) => j.intersects(A, R)), j = q.pop();
    return I;
  }, O = (_, R) => (t("comp", _, R), _ = E(_, R), t("caret", _), _ = y(_, R), t("tildes", _), _ = w(_, R), t("xrange", _), _ = T(_, R), t("stars", _), _), p = (_) => !_ || _.toLowerCase() === "x" || _ === "*", y = (_, R) => _.trim().split(/\s+/).map((I) => L(I, R)).join(" "), L = (_, R) => {
    const I = R.loose ? n[a.TILDELOOSE] : n[a.TILDE];
    return _.replace(I, (q, j, A, x, D) => {
      t("tilde", _, q, j, A, x, D);
      let N;
      return p(j) ? N = "" : p(A) ? N = `>=${j}.0.0 <${+j + 1}.0.0-0` : p(x) ? N = `>=${j}.${A}.0 <${j}.${+A + 1}.0-0` : D ? (t("replaceTilde pr", D), N = `>=${j}.${A}.${x}-${D} <${j}.${+A + 1}.0-0`) : N = `>=${j}.${A}.${x} <${j}.${+A + 1}.0-0`, t("tilde return", N), N;
    });
  }, E = (_, R) => _.trim().split(/\s+/).map((I) => d(I, R)).join(" "), d = (_, R) => {
    t("caret", _, R);
    const I = R.loose ? n[a.CARETLOOSE] : n[a.CARET], q = R.includePrerelease ? "-0" : "";
    return _.replace(I, (j, A, x, D, N) => {
      t("caret", _, j, A, x, D, N);
      let m;
      return p(A) ? m = "" : p(x) ? m = `>=${A}.0.0${q} <${+A + 1}.0.0-0` : p(D) ? A === "0" ? m = `>=${A}.${x}.0${q} <${A}.${+x + 1}.0-0` : m = `>=${A}.${x}.0${q} <${+A + 1}.0.0-0` : N ? (t("replaceCaret pr", N), A === "0" ? x === "0" ? m = `>=${A}.${x}.${D}-${N} <${A}.${x}.${+D + 1}-0` : m = `>=${A}.${x}.${D}-${N} <${A}.${+x + 1}.0-0` : m = `>=${A}.${x}.${D}-${N} <${+A + 1}.0.0-0`) : (t("no pr"), A === "0" ? x === "0" ? m = `>=${A}.${x}.${D}${q} <${A}.${x}.${+D + 1}-0` : m = `>=${A}.${x}.${D}${q} <${A}.${+x + 1}.0-0` : m = `>=${A}.${x}.${D} <${+A + 1}.0.0-0`), t("caret return", m), m;
    });
  }, w = (_, R) => (t("replaceXRanges", _, R), _.split(/\s+/).map((I) => $(I, R)).join(" ")), $ = (_, R) => {
    _ = _.trim();
    const I = R.loose ? n[a.XRANGELOOSE] : n[a.XRANGE];
    return _.replace(I, (q, j, A, x, D, N) => {
      t("xRange", _, q, j, A, x, D, N);
      const m = p(A), k = m || p(x), U = k || p(D), Y = U;
      return j === "=" && Y && (j = ""), N = R.includePrerelease ? "-0" : "", m ? j === ">" || j === "<" ? q = "<0.0.0-0" : q = "*" : j && Y ? (k && (x = 0), D = 0, j === ">" ? (j = ">=", k ? (A = +A + 1, x = 0, D = 0) : (x = +x + 1, D = 0)) : j === "<=" && (j = "<", k ? A = +A + 1 : x = +x + 1), j === "<" && (N = "-0"), q = `${j + A}.${x}.${D}${N}`) : k ? q = `>=${A}.0.0${N} <${+A + 1}.0.0-0` : U && (q = `>=${A}.${x}.0${N} <${A}.${+x + 1}.0-0`), t("xRange return", q), q;
    });
  }, T = (_, R) => (t("replaceStars", _, R), _.trim().replace(n[a.STAR], "")), B = (_, R) => (t("replaceGTE0", _, R), _.trim().replace(n[R.includePrerelease ? a.GTE0PRE : a.GTE0], "")), M = (_) => (R, I, q, j, A, x, D, N, m, k, U, Y, v) => (p(q) ? I = "" : p(j) ? I = `>=${q}.0.0${_ ? "-0" : ""}` : p(A) ? I = `>=${q}.${j}.0${_ ? "-0" : ""}` : x ? I = `>=${I}` : I = `>=${I}${_ ? "-0" : ""}`, p(m) ? N = "" : p(k) ? N = `<${+m + 1}.0.0-0` : p(U) ? N = `<${m}.${+k + 1}.0-0` : Y ? N = `<=${m}.${k}.${U}-${Y}` : _ ? N = `<${m}.${k}.${+U + 1}-0` : N = `<=${N}`, `${I} ${N}`.trim()), G = (_, R, I) => {
    for (let q = 0; q < _.length; q++)
      if (!_[q].test(R))
        return !1;
    if (R.prerelease.length && !I.includePrerelease) {
      for (let q = 0; q < _.length; q++)
        if (t(_[q].semver), _[q].semver !== u.ANY && _[q].semver.prerelease.length > 0) {
          const j = _[q].semver;
          if (j.major === R.major && j.minor === R.minor && j.patch === R.patch)
            return !0;
        }
      return !1;
    }
    return !0;
  };
  return Pt;
}
var Dt, gn;
function ke() {
  if (gn) return Dt;
  gn = 1;
  const e = Symbol("SemVer ANY");
  class s {
    static get ANY() {
      return e;
    }
    constructor(l, h) {
      if (h = i(h), l instanceof s) {
        if (l.loose === !!h.loose)
          return l;
        l = l.value;
      }
      r("comparator", l, h), this.options = h, this.loose = !!h.loose, this.parse(l), this.semver === e ? this.value = "" : this.value = this.operator + this.semver.version, r("comp", this);
    }
    parse(l) {
      const h = this.options.loose ? o[u.COMPARATORLOOSE] : o[u.COMPARATOR], f = l.match(h);
      if (!f)
        throw new TypeError(`Invalid comparator: ${l}`);
      this.operator = f[1] !== void 0 ? f[1] : "", this.operator === "=" && (this.operator = ""), f[2] ? this.semver = new n(f[2], this.options.loose) : this.semver = e;
    }
    toString() {
      return this.value;
    }
    test(l) {
      if (r("Comparator.test", l, this.options.loose), this.semver === e || l === e)
        return !0;
      if (typeof l == "string")
        try {
          l = new n(l, this.options);
        } catch {
          return !1;
        }
      return t(l, this.operator, this.semver, this.options);
    }
    intersects(l, h) {
      if (!(l instanceof s))
        throw new TypeError("a Comparator is required");
      if ((!h || typeof h != "object") && (h = {
        loose: !!h,
        includePrerelease: !1
      }), this.operator === "")
        return this.value === "" ? !0 : new a(l.value, h).test(this.value);
      if (l.operator === "")
        return l.value === "" ? !0 : new a(this.value, h).test(l.semver);
      const f = (this.operator === ">=" || this.operator === ">") && (l.operator === ">=" || l.operator === ">"), g = (this.operator === "<=" || this.operator === "<") && (l.operator === "<=" || l.operator === "<"), b = this.semver.version === l.semver.version, O = (this.operator === ">=" || this.operator === "<=") && (l.operator === ">=" || l.operator === "<="), p = t(this.semver, "<", l.semver, h) && (this.operator === ">=" || this.operator === ">") && (l.operator === "<=" || l.operator === "<"), y = t(this.semver, ">", l.semver, h) && (this.operator === "<=" || this.operator === "<") && (l.operator === ">=" || l.operator === ">");
      return f || g || b && O || p || y;
    }
  }
  Dt = s;
  const i = Fe(), { re: o, t: u } = be(), t = as(), r = Me(), n = ae(), a = pe();
  return Dt;
}
var qt, mn;
function Ve() {
  if (mn) return qt;
  mn = 1;
  const e = pe();
  return qt = (i, o, u) => {
    try {
      o = new e(o, u);
    } catch {
      return !1;
    }
    return o.test(i);
  }, qt;
}
var Ht, En;
function ti() {
  if (En) return Ht;
  En = 1;
  const e = pe();
  return Ht = (i, o) => new e(i, o).set.map((u) => u.map((t) => t.value).join(" ").trim().split(" ")), Ht;
}
var jt, vn;
function ri() {
  if (vn) return jt;
  vn = 1;
  const e = ae(), s = pe();
  return jt = (o, u, t) => {
    let r = null, n = null, a = null;
    try {
      a = new s(u, t);
    } catch {
      return null;
    }
    return o.forEach((c) => {
      a.test(c) && (!r || n.compare(c) === -1) && (r = c, n = new e(r, t));
    }), r;
  }, jt;
}
var Gt, Rn;
function ni() {
  if (Rn) return Gt;
  Rn = 1;
  const e = ae(), s = pe();
  return Gt = (o, u, t) => {
    let r = null, n = null, a = null;
    try {
      a = new s(u, t);
    } catch {
      return null;
    }
    return o.forEach((c) => {
      a.test(c) && (!r || n.compare(c) === 1) && (r = c, n = new e(r, t));
    }), r;
  }, Gt;
}
var Bt, yn;
function si() {
  if (yn) return Bt;
  yn = 1;
  const e = ae(), s = pe(), i = Ue();
  return Bt = (u, t) => {
    u = new s(u, t);
    let r = new e("0.0.0");
    if (u.test(r) || (r = new e("0.0.0-0"), u.test(r)))
      return r;
    r = null;
    for (let n = 0; n < u.set.length; ++n) {
      const a = u.set[n];
      let c = null;
      a.forEach((l) => {
        const h = new e(l.semver.version);
        switch (l.operator) {
          case ">":
            h.prerelease.length === 0 ? h.patch++ : h.prerelease.push(0), h.raw = h.format();
          /* fallthrough */
          case "":
          case ">=":
            (!c || i(h, c)) && (c = h);
            break;
          case "<":
          case "<=":
            break;
          /* istanbul ignore next */
          default:
            throw new Error(`Unexpected operation: ${l.operator}`);
        }
      }), c && (!r || i(r, c)) && (r = c);
    }
    return r && u.test(r) ? r : null;
  }, Bt;
}
var Mt, $n;
function ii() {
  if ($n) return Mt;
  $n = 1;
  const e = pe();
  return Mt = (i, o) => {
    try {
      return new e(i, o).range || "*";
    } catch {
      return null;
    }
  }, Mt;
}
var Ft, An;
function mr() {
  if (An) return Ft;
  An = 1;
  const e = ae(), s = ke(), { ANY: i } = s, o = pe(), u = Ve(), t = Ue(), r = pr(), n = gr(), a = dr();
  return Ft = (l, h, f, g) => {
    l = new e(l, g), h = new o(h, g);
    let b, O, p, y, L;
    switch (f) {
      case ">":
        b = t, O = n, p = r, y = ">", L = ">=";
        break;
      case "<":
        b = r, O = a, p = t, y = "<", L = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (u(l, h, g))
      return !1;
    for (let E = 0; E < h.set.length; ++E) {
      const d = h.set[E];
      let w = null, $ = null;
      if (d.forEach((T) => {
        T.semver === i && (T = new s(">=0.0.0")), w = w || T, $ = $ || T, b(T.semver, w.semver, g) ? w = T : p(T.semver, $.semver, g) && ($ = T);
      }), w.operator === y || w.operator === L || (!$.operator || $.operator === y) && O(l, $.semver))
        return !1;
      if ($.operator === L && p(l, $.semver))
        return !1;
    }
    return !0;
  }, Ft;
}
var Ut, wn;
function oi() {
  if (wn) return Ut;
  wn = 1;
  const e = mr();
  return Ut = (i, o, u) => e(i, o, ">", u), Ut;
}
var kt, Sn;
function ai() {
  if (Sn) return kt;
  Sn = 1;
  const e = mr();
  return kt = (i, o, u) => e(i, o, "<", u), kt;
}
var Vt, bn;
function ui() {
  if (bn) return Vt;
  bn = 1;
  const e = pe();
  return Vt = (i, o, u) => (i = new e(i, u), o = new e(o, u), i.intersects(o)), Vt;
}
var Xt, On;
function ci() {
  if (On) return Xt;
  On = 1;
  const e = Ve(), s = he();
  return Xt = (i, o, u) => {
    const t = [];
    let r = null, n = null;
    const a = i.sort((f, g) => s(f, g, u));
    for (const f of a)
      e(f, o, u) ? (n = f, r || (r = f)) : (n && t.push([r, n]), n = null, r = null);
    r && t.push([r, null]);
    const c = [];
    for (const [f, g] of t)
      f === g ? c.push(f) : !g && f === a[0] ? c.push("*") : g ? f === a[0] ? c.push(`<=${g}`) : c.push(`${f} - ${g}`) : c.push(`>=${f}`);
    const l = c.join(" || "), h = typeof o.raw == "string" ? o.raw : String(o);
    return l.length < h.length ? l : o;
  }, Xt;
}
var Kt, _n;
function li() {
  if (_n) return Kt;
  _n = 1;
  const e = pe(), s = ke(), { ANY: i } = s, o = Ve(), u = he(), t = (c, l, h = {}) => {
    if (c === l)
      return !0;
    c = new e(c, h), l = new e(l, h);
    let f = !1;
    e: for (const g of c.set) {
      for (const b of l.set) {
        const O = r(g, b, h);
        if (f = f || O !== null, O)
          continue e;
      }
      if (f)
        return !1;
    }
    return !0;
  }, r = (c, l, h) => {
    if (c === l)
      return !0;
    if (c.length === 1 && c[0].semver === i) {
      if (l.length === 1 && l[0].semver === i)
        return !0;
      h.includePrerelease ? c = [new s(">=0.0.0-0")] : c = [new s(">=0.0.0")];
    }
    if (l.length === 1 && l[0].semver === i) {
      if (h.includePrerelease)
        return !0;
      l = [new s(">=0.0.0")];
    }
    const f = /* @__PURE__ */ new Set();
    let g, b;
    for (const $ of c)
      $.operator === ">" || $.operator === ">=" ? g = n(g, $, h) : $.operator === "<" || $.operator === "<=" ? b = a(b, $, h) : f.add($.semver);
    if (f.size > 1)
      return null;
    let O;
    if (g && b) {
      if (O = u(g.semver, b.semver, h), O > 0)
        return null;
      if (O === 0 && (g.operator !== ">=" || b.operator !== "<="))
        return null;
    }
    for (const $ of f) {
      if (g && !o($, String(g), h) || b && !o($, String(b), h))
        return null;
      for (const T of l)
        if (!o($, String(T), h))
          return !1;
      return !0;
    }
    let p, y, L, E, d = b && !h.includePrerelease && b.semver.prerelease.length ? b.semver : !1, w = g && !h.includePrerelease && g.semver.prerelease.length ? g.semver : !1;
    d && d.prerelease.length === 1 && b.operator === "<" && d.prerelease[0] === 0 && (d = !1);
    for (const $ of l) {
      if (E = E || $.operator === ">" || $.operator === ">=", L = L || $.operator === "<" || $.operator === "<=", g) {
        if (w && $.semver.prerelease && $.semver.prerelease.length && $.semver.major === w.major && $.semver.minor === w.minor && $.semver.patch === w.patch && (w = !1), $.operator === ">" || $.operator === ">=") {
          if (p = n(g, $, h), p === $ && p !== g)
            return !1;
        } else if (g.operator === ">=" && !o(g.semver, String($), h))
          return !1;
      }
      if (b) {
        if (d && $.semver.prerelease && $.semver.prerelease.length && $.semver.major === d.major && $.semver.minor === d.minor && $.semver.patch === d.patch && (d = !1), $.operator === "<" || $.operator === "<=") {
          if (y = a(b, $, h), y === $ && y !== b)
            return !1;
        } else if (b.operator === "<=" && !o(b.semver, String($), h))
          return !1;
      }
      if (!$.operator && (b || g) && O !== 0)
        return !1;
    }
    return !(g && L && !b && O !== 0 || b && E && !g && O !== 0 || w || d);
  }, n = (c, l, h) => {
    if (!c)
      return l;
    const f = u(c.semver, l.semver, h);
    return f > 0 ? c : f < 0 || l.operator === ">" && c.operator === ">=" ? l : c;
  }, a = (c, l, h) => {
    if (!c)
      return l;
    const f = u(c.semver, l.semver, h);
    return f < 0 ? c : f > 0 || l.operator === "<" && c.operator === "<=" ? l : c;
  };
  return Kt = t, Kt;
}
var zt, Tn;
function fi() {
  if (Tn) return zt;
  Tn = 1;
  const e = be(), s = Be(), i = ae(), o = is(), u = Oe(), t = Gs(), r = Bs(), n = Ms(), a = Fs(), c = Us(), l = ks(), h = Vs(), f = Xs(), g = he(), b = Ks(), O = zs(), p = hr(), y = Ws(), L = Ys(), E = Ue(), d = pr(), w = fr(), $ = os(), T = dr(), B = gr(), M = as(), G = Zs(), _ = ke(), R = pe(), I = Ve(), q = ti(), j = ri(), A = ni(), x = si(), D = ii(), N = mr(), m = oi(), k = ai(), U = ui(), Y = ci(), v = li();
  return zt = {
    parse: u,
    valid: t,
    clean: r,
    inc: n,
    diff: a,
    major: c,
    minor: l,
    patch: h,
    prerelease: f,
    compare: g,
    rcompare: b,
    compareLoose: O,
    compareBuild: p,
    sort: y,
    rsort: L,
    gt: E,
    lt: d,
    eq: w,
    neq: $,
    gte: T,
    lte: B,
    cmp: M,
    coerce: G,
    Comparator: _,
    Range: R,
    satisfies: I,
    toComparators: q,
    maxSatisfying: j,
    minSatisfying: A,
    minVersion: x,
    validRange: D,
    outside: N,
    gtr: m,
    ltr: k,
    intersects: U,
    simplifyRange: Y,
    subset: v,
    SemVer: i,
    re: e.re,
    src: e.src,
    tokens: e.t,
    SEMVER_SPEC_VERSION: s.SEMVER_SPEC_VERSION,
    compareIdentifiers: o.compareIdentifiers,
    rcompareIdentifiers: o.rcompareIdentifiers
  }, zt;
}
var re = fi();
const hi = [
  [1e3, 6e4, "sec"],
  [6e4, 36e5, "min"],
  [36e5, 864e5, "hour"],
  [864e5, 6048e5, "day"],
  [6048e5, 2628e6, "week"],
  [2628e6, 31536e6, "month"],
  [31536e6, 1 / 0, "year"]
], pi = {
  "1 day ago": "yesterday",
  "1 week ago": "last week",
  "1 month ago": "last month",
  "1 year ago": "last year",
  "in 1 day": "tomorrow",
  "in 1 week": "next week",
  "in 1 month": "next month",
  "in 1 year": "next year"
}, di = {
  sec: "second",
  min: "minute"
};
function In(e) {
  return e instanceof Date ? e.getTime() : typeof e == "string" ? Date.parse(e) : e;
}
function xn(e, { now: s, noAffix: i = !1, times: o = hi, nowThreshold: u = 2e3, nowString: t = "now", unknownString: r = "", aliases: n = !1, aliasesMap: a = pi, longUnits: c = !1 } = {}) {
  const l = In(e);
  if (s = s !== void 0 ? In(s) : Date.now(), Number.isNaN(l)) return r || String(e);
  let h = !1, f = s - l;
  if (f < 0 && (h = !0, f = Math.abs(f)), f < u) return t;
  let g = 0, b = "";
  for (let p = 0, y = o.length; p < y; p++) {
    const L = o[p];
    if (!(f >= L[1])) {
      g = Math.floor(f / L[0]), b = (c && di[L[2]] || L[2]) + (g > 1 ? "s" : "");
      break;
    }
  }
  const O = `${h && !i ? "in " : ""}${g} ${b}${!h && !i ? " ago" : ""}`;
  return n ? a[O] ?? O : O;
}
function le(e, s = globalThis.Deno ? globalThis.Deno.args : ur.argv) {
  const i = e.startsWith("-") ? "" : e.length === 1 ? "-" : "--", o = s.indexOf(i + e), u = s.indexOf("--");
  return o !== -1 && (u === -1 || o < u);
}
const { env: Q } = ur;
let qe;
le("no-color") || le("no-colors") || le("color=false") || le("color=never") ? qe = 0 : (le("color") || le("colors") || le("color=true") || le("color=always")) && (qe = 1);
function gi() {
  if (!("FORCE_COLOR" in Q))
    return;
  if (Q.FORCE_COLOR === "true")
    return 1;
  if (Q.FORCE_COLOR === "false")
    return 0;
  if (Q.FORCE_COLOR.length === 0)
    return 1;
  const e = Math.min(Number.parseInt(Q.FORCE_COLOR, 10), 3);
  if ([0, 1, 2, 3].includes(e))
    return e;
}
function mi(e) {
  return e === 0 ? !1 : {
    level: e,
    hasBasic: !0,
    has256: e >= 2,
    has16m: e >= 3
  };
}
function Ei(e, { streamIsTTY: s, sniffFlags: i = !0 } = {}) {
  const o = gi();
  o !== void 0 && (qe = o);
  const u = i ? qe : o;
  if (u === 0)
    return 0;
  if (i) {
    if (le("color=16m") || le("color=full") || le("color=truecolor"))
      return 3;
    if (le("color=256"))
      return 2;
  }
  if ("TF_BUILD" in Q && "AGENT_NAME" in Q)
    return 1;
  if (e && !s && u === void 0)
    return 0;
  const t = u || 0;
  if (Q.TERM === "dumb")
    return t;
  if (ur.platform === "win32") {
    const r = Os.release().split(".");
    return Number(r[0]) >= 10 && Number(r[2]) >= 10586 ? Number(r[2]) >= 14931 ? 3 : 2 : 1;
  }
  if ("CI" in Q)
    return ["GITHUB_ACTIONS", "GITEA_ACTIONS", "CIRCLECI"].some((r) => r in Q) ? 3 : ["TRAVIS", "APPVEYOR", "GITLAB_CI", "BUILDKITE", "DRONE"].some((r) => r in Q) || Q.CI_NAME === "codeship" ? 1 : t;
  if ("TEAMCITY_VERSION" in Q)
    return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(Q.TEAMCITY_VERSION) ? 1 : 0;
  if (Q.COLORTERM === "truecolor" || Q.TERM === "xterm-kitty")
    return 3;
  if ("TERM_PROGRAM" in Q) {
    const r = Number.parseInt((Q.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
    switch (Q.TERM_PROGRAM) {
      case "iTerm.app":
        return r >= 3 ? 3 : 2;
      case "Apple_Terminal":
        return 2;
    }
  }
  return /-256(color)?$/i.test(Q.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(Q.TERM) || "COLORTERM" in Q ? 1 : t;
}
function Cn(e, s = {}) {
  const i = Ei(e, {
    streamIsTTY: e && e.isTTY,
    ...s
  });
  return mi(i);
}
const vi = {
  stdout: Cn({ isTTY: Or.isatty(1) }),
  stderr: Cn({ isTTY: Or.isatty(2) })
};
let us = !0;
function Ri() {
  us = !1;
}
function Er(e, s, i) {
  const o = e.join(" ");
  return us ? `\x1B[${s}m${o}\x1B[${i}m` : o;
}
const vr = (...e) => Er(e, 31, 39), Rr = (...e) => Er(e, 32, 39), yi = (...e) => Er(e, 35, 39);
class $i extends Error {
  constructor(s) {
    super(), this.name = "AbortError", this.message = s;
  }
}
const Ln = (e) => globalThis.DOMException === void 0 ? new $i(e) : new DOMException(e), Nn = (e) => {
  const s = e.reason === void 0 ? Ln("This operation was aborted.") : e.reason;
  return s instanceof Error ? s : Ln(s);
};
async function Ai(e, s, {
  concurrency: i = Number.POSITIVE_INFINITY,
  stopOnError: o = !0,
  signal: u
} = {}) {
  return new Promise((t, r) => {
    if (e[Symbol.iterator] === void 0 && e[Symbol.asyncIterator] === void 0)
      throw new TypeError(`Expected \`input\` to be either an \`Iterable\` or \`AsyncIterable\`, got (${typeof e})`);
    if (typeof s != "function")
      throw new TypeError("Mapper function is required");
    if (!((Number.isSafeInteger(i) || i === Number.POSITIVE_INFINITY) && i >= 1))
      throw new TypeError(`Expected \`concurrency\` to be an integer from 1 and up or \`Infinity\`, got \`${i}\` (${typeof i})`);
    const n = [], a = [], c = /* @__PURE__ */ new Map();
    let l = !1, h = !1, f = !1, g = 0, b = 0;
    const O = e[Symbol.iterator] === void 0 ? e[Symbol.asyncIterator]() : e[Symbol.iterator](), p = (L) => {
      l = !0, h = !0, r(L);
    };
    u && (u.aborted && p(Nn(u)), u.addEventListener("abort", () => {
      p(Nn(u));
    }));
    const y = async () => {
      if (h)
        return;
      const L = await O.next(), E = b;
      if (b++, L.done) {
        if (f = !0, g === 0 && !h) {
          if (!o && a.length > 0) {
            p(new AggregateError(a));
            return;
          }
          if (h = !0, c.size === 0) {
            t(n);
            return;
          }
          const d = [];
          for (const [w, $] of n.entries())
            c.get(w) !== Pn && d.push($);
          t(d);
        }
        return;
      }
      g++, (async () => {
        try {
          const d = await L.value;
          if (h)
            return;
          const w = await s(d, E);
          w === Pn && c.set(E, w), n[E] = w, g--, await y();
        } catch (d) {
          if (o)
            p(d);
          else {
            a.push(d), g--;
            try {
              await y();
            } catch (w) {
              p(w);
            }
          }
        }
      })();
    };
    (async () => {
      for (let L = 0; L < i; L++) {
        try {
          await y();
        } catch (E) {
          p(E);
          break;
        }
        if (f || l)
          break;
      }
    })();
  });
}
const Pn = Symbol("skip");
async function Dn(e, s) {
  return Ai(e, (i) => i(), s);
}
var Wt = {}, Yt, qn;
function Xe() {
  if (qn) return Yt;
  qn = 1;
  const e = "\\\\/", s = `[^${e}]`, i = "\\.", o = "\\+", u = "\\?", t = "\\/", r = "(?=.)", n = "[^/]", a = `(?:${t}|$)`, c = `(?:^|${t})`, l = `${i}{1,2}${a}`, h = `(?!${i})`, f = `(?!${c}${l})`, g = `(?!${i}{0,1}${a})`, b = `(?!${l})`, O = `[^.${t}]`, p = `${n}*?`, L = {
    DOT_LITERAL: i,
    PLUS_LITERAL: o,
    QMARK_LITERAL: u,
    SLASH_LITERAL: t,
    ONE_CHAR: r,
    QMARK: n,
    END_ANCHOR: a,
    DOTS_SLASH: l,
    NO_DOT: h,
    NO_DOTS: f,
    NO_DOT_SLASH: g,
    NO_DOTS_SLASH: b,
    QMARK_NO_DOT: O,
    STAR: p,
    START_ANCHOR: c,
    SEP: "/"
  }, E = {
    ...L,
    SLASH_LITERAL: `[${e}]`,
    QMARK: s,
    STAR: `${s}*?`,
    DOTS_SLASH: `${i}{1,2}(?:[${e}]|$)`,
    NO_DOT: `(?!${i})`,
    NO_DOTS: `(?!(?:^|[${e}])${i}{1,2}(?:[${e}]|$))`,
    NO_DOT_SLASH: `(?!${i}{0,1}(?:[${e}]|$))`,
    NO_DOTS_SLASH: `(?!${i}{1,2}(?:[${e}]|$))`,
    QMARK_NO_DOT: `[^.${e}]`,
    START_ANCHOR: `(?:^|[${e}])`,
    END_ANCHOR: `(?:[${e}]|$)`,
    SEP: "\\"
  }, d = {
    alnum: "a-zA-Z0-9",
    alpha: "a-zA-Z",
    ascii: "\\x00-\\x7F",
    blank: " \\t",
    cntrl: "\\x00-\\x1F\\x7F",
    digit: "0-9",
    graph: "\\x21-\\x7E",
    lower: "a-z",
    print: "\\x20-\\x7E ",
    punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
    space: " \\t\\r\\n\\v\\f",
    upper: "A-Z",
    word: "A-Za-z0-9_",
    xdigit: "A-Fa-f0-9"
  };
  return Yt = {
    MAX_LENGTH: 1024 * 64,
    POSIX_REGEX_SOURCE: d,
    // regular expressions
    REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
    REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
    REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
    REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
    REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
    REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
    // Replace globs with equivalent patterns to reduce parsing time.
    REPLACEMENTS: {
      "***": "*",
      "**/**": "**",
      "**/**/**": "**"
    },
    // Digits
    CHAR_0: 48,
    /* 0 */
    CHAR_9: 57,
    /* 9 */
    // Alphabet chars.
    CHAR_UPPERCASE_A: 65,
    /* A */
    CHAR_LOWERCASE_A: 97,
    /* a */
    CHAR_UPPERCASE_Z: 90,
    /* Z */
    CHAR_LOWERCASE_Z: 122,
    /* z */
    CHAR_LEFT_PARENTHESES: 40,
    /* ( */
    CHAR_RIGHT_PARENTHESES: 41,
    /* ) */
    CHAR_ASTERISK: 42,
    /* * */
    // Non-alphabetic chars.
    CHAR_AMPERSAND: 38,
    /* & */
    CHAR_AT: 64,
    /* @ */
    CHAR_BACKWARD_SLASH: 92,
    /* \ */
    CHAR_CARRIAGE_RETURN: 13,
    /* \r */
    CHAR_CIRCUMFLEX_ACCENT: 94,
    /* ^ */
    CHAR_COLON: 58,
    /* : */
    CHAR_COMMA: 44,
    /* , */
    CHAR_DOT: 46,
    /* . */
    CHAR_DOUBLE_QUOTE: 34,
    /* " */
    CHAR_EQUAL: 61,
    /* = */
    CHAR_EXCLAMATION_MARK: 33,
    /* ! */
    CHAR_FORM_FEED: 12,
    /* \f */
    CHAR_FORWARD_SLASH: 47,
    /* / */
    CHAR_GRAVE_ACCENT: 96,
    /* ` */
    CHAR_HASH: 35,
    /* # */
    CHAR_HYPHEN_MINUS: 45,
    /* - */
    CHAR_LEFT_ANGLE_BRACKET: 60,
    /* < */
    CHAR_LEFT_CURLY_BRACE: 123,
    /* { */
    CHAR_LEFT_SQUARE_BRACKET: 91,
    /* [ */
    CHAR_LINE_FEED: 10,
    /* \n */
    CHAR_NO_BREAK_SPACE: 160,
    /* \u00A0 */
    CHAR_PERCENT: 37,
    /* % */
    CHAR_PLUS: 43,
    /* + */
    CHAR_QUESTION_MARK: 63,
    /* ? */
    CHAR_RIGHT_ANGLE_BRACKET: 62,
    /* > */
    CHAR_RIGHT_CURLY_BRACE: 125,
    /* } */
    CHAR_RIGHT_SQUARE_BRACKET: 93,
    /* ] */
    CHAR_SEMICOLON: 59,
    /* ; */
    CHAR_SINGLE_QUOTE: 39,
    /* ' */
    CHAR_SPACE: 32,
    /*   */
    CHAR_TAB: 9,
    /* \t */
    CHAR_UNDERSCORE: 95,
    /* _ */
    CHAR_VERTICAL_LINE: 124,
    /* | */
    CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
    /* \uFEFF */
    /**
     * Create EXTGLOB_CHARS
     */
    extglobChars(w) {
      return {
        "!": { type: "negate", open: "(?:(?!(?:", close: `))${w.STAR})` },
        "?": { type: "qmark", open: "(?:", close: ")?" },
        "+": { type: "plus", open: "(?:", close: ")+" },
        "*": { type: "star", open: "(?:", close: ")*" },
        "@": { type: "at", open: "(?:", close: ")" }
      };
    },
    /**
     * Create GLOB_CHARS
     */
    globChars(w) {
      return w === !0 ? E : L;
    }
  }, Yt;
}
var Hn;
function Ke() {
  return Hn || (Hn = 1, function(e) {
    const {
      REGEX_BACKSLASH: s,
      REGEX_REMOVE_BACKSLASH: i,
      REGEX_SPECIAL_CHARS: o,
      REGEX_SPECIAL_CHARS_GLOBAL: u
    } = /* @__PURE__ */ Xe();
    e.isObject = (t) => t !== null && typeof t == "object" && !Array.isArray(t), e.hasRegexChars = (t) => o.test(t), e.isRegexChar = (t) => t.length === 1 && e.hasRegexChars(t), e.escapeRegex = (t) => t.replace(u, "\\$1"), e.toPosixSlashes = (t) => t.replace(s, "/"), e.isWindows = () => {
      if (typeof navigator < "u" && navigator.platform) {
        const t = navigator.platform.toLowerCase();
        return t === "win32" || t === "windows";
      }
      return typeof process < "u" && process.platform ? process.platform === "win32" : !1;
    }, e.removeBackslashes = (t) => t.replace(i, (r) => r === "\\" ? "" : r), e.escapeLast = (t, r, n) => {
      const a = t.lastIndexOf(r, n);
      return a === -1 ? t : t[a - 1] === "\\" ? e.escapeLast(t, r, a - 1) : `${t.slice(0, a)}\\${t.slice(a)}`;
    }, e.removePrefix = (t, r = {}) => {
      let n = t;
      return n.startsWith("./") && (n = n.slice(2), r.prefix = "./"), n;
    }, e.wrapOutput = (t, r = {}, n = {}) => {
      const a = n.contains ? "" : "^", c = n.contains ? "" : "$";
      let l = `${a}(?:${t})${c}`;
      return r.negated === !0 && (l = `(?:^(?!${l}).*$)`), l;
    }, e.basename = (t, { windows: r } = {}) => {
      const n = t.split(r ? /[\\/]/ : "/"), a = n[n.length - 1];
      return a === "" ? n[n.length - 2] : a;
    };
  }(Wt)), Wt;
}
var Zt, jn;
function wi() {
  if (jn) return Zt;
  jn = 1;
  const e = /* @__PURE__ */ Ke(), {
    CHAR_ASTERISK: s,
    /* * */
    CHAR_AT: i,
    /* @ */
    CHAR_BACKWARD_SLASH: o,
    /* \ */
    CHAR_COMMA: u,
    /* , */
    CHAR_DOT: t,
    /* . */
    CHAR_EXCLAMATION_MARK: r,
    /* ! */
    CHAR_FORWARD_SLASH: n,
    /* / */
    CHAR_LEFT_CURLY_BRACE: a,
    /* { */
    CHAR_LEFT_PARENTHESES: c,
    /* ( */
    CHAR_LEFT_SQUARE_BRACKET: l,
    /* [ */
    CHAR_PLUS: h,
    /* + */
    CHAR_QUESTION_MARK: f,
    /* ? */
    CHAR_RIGHT_CURLY_BRACE: g,
    /* } */
    CHAR_RIGHT_PARENTHESES: b,
    /* ) */
    CHAR_RIGHT_SQUARE_BRACKET: O
    /* ] */
  } = /* @__PURE__ */ Xe(), p = (E) => E === n || E === o, y = (E) => {
    E.isPrefix !== !0 && (E.depth = E.isGlobstar ? 1 / 0 : 1);
  };
  return Zt = (E, d) => {
    const w = d || {}, $ = E.length - 1, T = w.parts === !0 || w.scanToEnd === !0, B = [], M = [], G = [];
    let _ = E, R = -1, I = 0, q = 0, j = !1, A = !1, x = !1, D = !1, N = !1, m = !1, k = !1, U = !1, Y = !1, v = !1, S = 0, ce, H, X = { value: "", depth: 0, isGlob: !1 };
    const ee = () => R >= $, fe = () => _.charCodeAt(R + 1), ne = () => (ce = H, _.charCodeAt(++R));
    for (; R < $; ) {
      H = ne();
      let ie;
      if (H === o) {
        k = X.backslashes = !0, H = ne(), H === a && (m = !0);
        continue;
      }
      if (m === !0 || H === a) {
        for (S++; ee() !== !0 && (H = ne()); ) {
          if (H === o) {
            k = X.backslashes = !0, ne();
            continue;
          }
          if (H === a) {
            S++;
            continue;
          }
          if (m !== !0 && H === t && (H = ne()) === t) {
            if (j = X.isBrace = !0, x = X.isGlob = !0, v = !0, T === !0)
              continue;
            break;
          }
          if (m !== !0 && H === u) {
            if (j = X.isBrace = !0, x = X.isGlob = !0, v = !0, T === !0)
              continue;
            break;
          }
          if (H === g && (S--, S === 0)) {
            m = !1, j = X.isBrace = !0, v = !0;
            break;
          }
        }
        if (T === !0)
          continue;
        break;
      }
      if (H === n) {
        if (B.push(R), M.push(X), X = { value: "", depth: 0, isGlob: !1 }, v === !0) continue;
        if (ce === t && R === I + 1) {
          I += 2;
          continue;
        }
        q = R + 1;
        continue;
      }
      if (w.noext !== !0 && (H === h || H === i || H === s || H === f || H === r) === !0 && fe() === c) {
        if (x = X.isGlob = !0, D = X.isExtglob = !0, v = !0, H === r && R === I && (Y = !0), T === !0) {
          for (; ee() !== !0 && (H = ne()); ) {
            if (H === o) {
              k = X.backslashes = !0, H = ne();
              continue;
            }
            if (H === b) {
              x = X.isGlob = !0, v = !0;
              break;
            }
          }
          continue;
        }
        break;
      }
      if (H === s) {
        if (ce === s && (N = X.isGlobstar = !0), x = X.isGlob = !0, v = !0, T === !0)
          continue;
        break;
      }
      if (H === f) {
        if (x = X.isGlob = !0, v = !0, T === !0)
          continue;
        break;
      }
      if (H === l) {
        for (; ee() !== !0 && (ie = ne()); ) {
          if (ie === o) {
            k = X.backslashes = !0, ne();
            continue;
          }
          if (ie === O) {
            A = X.isBracket = !0, x = X.isGlob = !0, v = !0;
            break;
          }
        }
        if (T === !0)
          continue;
        break;
      }
      if (w.nonegate !== !0 && H === r && R === I) {
        U = X.negated = !0, I++;
        continue;
      }
      if (w.noparen !== !0 && H === c) {
        if (x = X.isGlob = !0, T === !0) {
          for (; ee() !== !0 && (H = ne()); ) {
            if (H === c) {
              k = X.backslashes = !0, H = ne();
              continue;
            }
            if (H === b) {
              v = !0;
              break;
            }
          }
          continue;
        }
        break;
      }
      if (x === !0) {
        if (v = !0, T === !0)
          continue;
        break;
      }
    }
    w.noext === !0 && (D = !1, x = !1);
    let te = _, me = "", ue = "";
    I > 0 && (me = _.slice(0, I), _ = _.slice(I), q -= I), te && x === !0 && q > 0 ? (te = _.slice(0, q), ue = _.slice(q)) : x === !0 ? (te = "", ue = _) : te = _, te && te !== "" && te !== "/" && te !== _ && p(te.charCodeAt(te.length - 1)) && (te = te.slice(0, -1)), w.unescape === !0 && (ue && (ue = e.removeBackslashes(ue)), te && k === !0 && (te = e.removeBackslashes(te)));
    const F = {
      prefix: me,
      input: E,
      start: I,
      base: te,
      glob: ue,
      isBrace: j,
      isBracket: A,
      isGlob: x,
      isExtglob: D,
      isGlobstar: N,
      negated: U,
      negatedExtglob: Y
    };
    if (w.tokens === !0 && (F.maxDepth = 0, p(H) || M.push(X), F.tokens = M), w.parts === !0 || w.tokens === !0) {
      let ie;
      for (let se = 0; se < B.length; se++) {
        const P = ie ? ie + 1 : I, W = B[se], C = E.slice(P, W);
        w.tokens && (se === 0 && I !== 0 ? (M[se].isPrefix = !0, M[se].value = me) : M[se].value = C, y(M[se]), F.maxDepth += M[se].depth), (se !== 0 || C !== "") && G.push(C), ie = W;
      }
      if (ie && ie + 1 < E.length) {
        const se = E.slice(ie + 1);
        G.push(se), w.tokens && (M[M.length - 1].value = se, y(M[M.length - 1]), F.maxDepth += M[M.length - 1].depth);
      }
      F.slashes = B, F.parts = G;
    }
    return F;
  }, Zt;
}
var Qt, Gn;
function Si() {
  if (Gn) return Qt;
  Gn = 1;
  const e = /* @__PURE__ */ Xe(), s = /* @__PURE__ */ Ke(), {
    MAX_LENGTH: i,
    POSIX_REGEX_SOURCE: o,
    REGEX_NON_SPECIAL_CHARS: u,
    REGEX_SPECIAL_CHARS_BACKREF: t,
    REPLACEMENTS: r
  } = e, n = (l, h) => {
    if (typeof h.expandRange == "function")
      return h.expandRange(...l, h);
    l.sort();
    const f = `[${l.join("-")}]`;
    try {
      new RegExp(f);
    } catch {
      return l.map((b) => s.escapeRegex(b)).join("..");
    }
    return f;
  }, a = (l, h) => `Missing ${l}: "${h}" - use "\\\\${h}" to match literal characters`, c = (l, h) => {
    if (typeof l != "string")
      throw new TypeError("Expected a string");
    l = r[l] || l;
    const f = { ...h }, g = typeof f.maxLength == "number" ? Math.min(i, f.maxLength) : i;
    let b = l.length;
    if (b > g)
      throw new SyntaxError(`Input length: ${b}, exceeds maximum allowed length: ${g}`);
    const O = { type: "bos", value: "", output: f.prepend || "" }, p = [O], y = f.capture ? "" : "?:", L = e.globChars(f.windows), E = e.extglobChars(L), {
      DOT_LITERAL: d,
      PLUS_LITERAL: w,
      SLASH_LITERAL: $,
      ONE_CHAR: T,
      DOTS_SLASH: B,
      NO_DOT: M,
      NO_DOT_SLASH: G,
      NO_DOTS_SLASH: _,
      QMARK: R,
      QMARK_NO_DOT: I,
      STAR: q,
      START_ANCHOR: j
    } = L, A = (P) => `(${y}(?:(?!${j}${P.dot ? B : d}).)*?)`, x = f.dot ? "" : M, D = f.dot ? R : I;
    let N = f.bash === !0 ? A(f) : q;
    f.capture && (N = `(${N})`), typeof f.noext == "boolean" && (f.noextglob = f.noext);
    const m = {
      input: l,
      index: -1,
      start: 0,
      dot: f.dot === !0,
      consumed: "",
      output: "",
      prefix: "",
      backtrack: !1,
      negated: !1,
      brackets: 0,
      braces: 0,
      parens: 0,
      quotes: 0,
      globstar: !1,
      tokens: p
    };
    l = s.removePrefix(l, m), b = l.length;
    const k = [], U = [], Y = [];
    let v = O, S;
    const ce = () => m.index === b - 1, H = m.peek = (P = 1) => l[m.index + P], X = m.advance = () => l[++m.index] || "", ee = () => l.slice(m.index + 1), fe = (P = "", W = 0) => {
      m.consumed += P, m.index += W;
    }, ne = (P) => {
      m.output += P.output != null ? P.output : P.value, fe(P.value);
    }, te = () => {
      let P = 1;
      for (; H() === "!" && (H(2) !== "(" || H(3) === "?"); )
        X(), m.start++, P++;
      return P % 2 === 0 ? !1 : (m.negated = !0, m.start++, !0);
    }, me = (P) => {
      m[P]++, Y.push(P);
    }, ue = (P) => {
      m[P]--, Y.pop();
    }, F = (P) => {
      if (v.type === "globstar") {
        const W = m.braces > 0 && (P.type === "comma" || P.type === "brace"), C = P.extglob === !0 || k.length && (P.type === "pipe" || P.type === "paren");
        P.type !== "slash" && P.type !== "paren" && !W && !C && (m.output = m.output.slice(0, -v.output.length), v.type = "star", v.value = "*", v.output = N, m.output += v.output);
      }
      if (k.length && P.type !== "paren" && (k[k.length - 1].inner += P.value), (P.value || P.output) && ne(P), v && v.type === "text" && P.type === "text") {
        v.output = (v.output || v.value) + P.value, v.value += P.value;
        return;
      }
      P.prev = v, p.push(P), v = P;
    }, ie = (P, W) => {
      const C = { ...E[W], conditions: 1, inner: "" };
      C.prev = v, C.parens = m.parens, C.output = m.output;
      const K = (f.capture ? "(" : "") + C.open;
      me("parens"), F({ type: P, value: W, output: m.output ? "" : T }), F({ type: "paren", extglob: !0, value: X(), output: K }), k.push(C);
    }, se = (P) => {
      let W = P.close + (f.capture ? ")" : ""), C;
      if (P.type === "negate") {
        let K = N;
        if (P.inner && P.inner.length > 1 && P.inner.includes("/") && (K = A(f)), (K !== N || ce() || /^\)+$/.test(ee())) && (W = P.close = `)$))${K}`), P.inner.includes("*") && (C = ee()) && /^\.[^\\/.]+$/.test(C)) {
          const Z = c(C, { ...h, fastpaths: !1 }).output;
          W = P.close = `)${Z})${K})`;
        }
        P.prev.type === "bos" && (m.negatedExtglob = !0);
      }
      F({ type: "paren", extglob: !0, value: S, output: W }), ue("parens");
    };
    if (f.fastpaths !== !1 && !/(^[*!]|[/()[\]{}"])/.test(l)) {
      let P = !1, W = l.replace(t, (C, K, Z, oe, J, We) => oe === "\\" ? (P = !0, C) : oe === "?" ? K ? K + oe + (J ? R.repeat(J.length) : "") : We === 0 ? D + (J ? R.repeat(J.length) : "") : R.repeat(Z.length) : oe === "." ? d.repeat(Z.length) : oe === "*" ? K ? K + oe + (J ? N : "") : N : K ? C : `\\${C}`);
      return P === !0 && (f.unescape === !0 ? W = W.replace(/\\/g, "") : W = W.replace(/\\+/g, (C) => C.length % 2 === 0 ? "\\\\" : C ? "\\" : "")), W === l && f.contains === !0 ? (m.output = l, m) : (m.output = s.wrapOutput(W, m, h), m);
    }
    for (; !ce(); ) {
      if (S = X(), S === "\0")
        continue;
      if (S === "\\") {
        const C = H();
        if (C === "/" && f.bash !== !0 || C === "." || C === ";")
          continue;
        if (!C) {
          S += "\\", F({ type: "text", value: S });
          continue;
        }
        const K = /^\\+/.exec(ee());
        let Z = 0;
        if (K && K[0].length > 2 && (Z = K[0].length, m.index += Z, Z % 2 !== 0 && (S += "\\")), f.unescape === !0 ? S = X() : S += X(), m.brackets === 0) {
          F({ type: "text", value: S });
          continue;
        }
      }
      if (m.brackets > 0 && (S !== "]" || v.value === "[" || v.value === "[^")) {
        if (f.posix !== !1 && S === ":") {
          const C = v.value.slice(1);
          if (C.includes("[") && (v.posix = !0, C.includes(":"))) {
            const K = v.value.lastIndexOf("["), Z = v.value.slice(0, K), oe = v.value.slice(K + 2), J = o[oe];
            if (J) {
              v.value = Z + J, m.backtrack = !0, X(), !O.output && p.indexOf(v) === 1 && (O.output = T);
              continue;
            }
          }
        }
        (S === "[" && H() !== ":" || S === "-" && H() === "]") && (S = `\\${S}`), S === "]" && (v.value === "[" || v.value === "[^") && (S = `\\${S}`), f.posix === !0 && S === "!" && v.value === "[" && (S = "^"), v.value += S, ne({ value: S });
        continue;
      }
      if (m.quotes === 1 && S !== '"') {
        S = s.escapeRegex(S), v.value += S, ne({ value: S });
        continue;
      }
      if (S === '"') {
        m.quotes = m.quotes === 1 ? 0 : 1, f.keepQuotes === !0 && F({ type: "text", value: S });
        continue;
      }
      if (S === "(") {
        me("parens"), F({ type: "paren", value: S });
        continue;
      }
      if (S === ")") {
        if (m.parens === 0 && f.strictBrackets === !0)
          throw new SyntaxError(a("opening", "("));
        const C = k[k.length - 1];
        if (C && m.parens === C.parens + 1) {
          se(k.pop());
          continue;
        }
        F({ type: "paren", value: S, output: m.parens ? ")" : "\\)" }), ue("parens");
        continue;
      }
      if (S === "[") {
        if (f.nobracket === !0 || !ee().includes("]")) {
          if (f.nobracket !== !0 && f.strictBrackets === !0)
            throw new SyntaxError(a("closing", "]"));
          S = `\\${S}`;
        } else
          me("brackets");
        F({ type: "bracket", value: S });
        continue;
      }
      if (S === "]") {
        if (f.nobracket === !0 || v && v.type === "bracket" && v.value.length === 1) {
          F({ type: "text", value: S, output: `\\${S}` });
          continue;
        }
        if (m.brackets === 0) {
          if (f.strictBrackets === !0)
            throw new SyntaxError(a("opening", "["));
          F({ type: "text", value: S, output: `\\${S}` });
          continue;
        }
        ue("brackets");
        const C = v.value.slice(1);
        if (v.posix !== !0 && C[0] === "^" && !C.includes("/") && (S = `/${S}`), v.value += S, ne({ value: S }), f.literalBrackets === !1 || s.hasRegexChars(C))
          continue;
        const K = s.escapeRegex(v.value);
        if (m.output = m.output.slice(0, -v.value.length), f.literalBrackets === !0) {
          m.output += K, v.value = K;
          continue;
        }
        v.value = `(${y}${K}|${v.value})`, m.output += v.value;
        continue;
      }
      if (S === "{" && f.nobrace !== !0) {
        me("braces");
        const C = {
          type: "brace",
          value: S,
          output: "(",
          outputIndex: m.output.length,
          tokensIndex: m.tokens.length
        };
        U.push(C), F(C);
        continue;
      }
      if (S === "}") {
        const C = U[U.length - 1];
        if (f.nobrace === !0 || !C) {
          F({ type: "text", value: S, output: S });
          continue;
        }
        let K = ")";
        if (C.dots === !0) {
          const Z = p.slice(), oe = [];
          for (let J = Z.length - 1; J >= 0 && (p.pop(), Z[J].type !== "brace"); J--)
            Z[J].type !== "dots" && oe.unshift(Z[J].value);
          K = n(oe, f), m.backtrack = !0;
        }
        if (C.comma !== !0 && C.dots !== !0) {
          const Z = m.output.slice(0, C.outputIndex), oe = m.tokens.slice(C.tokensIndex);
          C.value = C.output = "\\{", S = K = "\\}", m.output = Z;
          for (const J of oe)
            m.output += J.output || J.value;
        }
        F({ type: "brace", value: S, output: K }), ue("braces"), U.pop();
        continue;
      }
      if (S === "|") {
        k.length > 0 && k[k.length - 1].conditions++, F({ type: "text", value: S });
        continue;
      }
      if (S === ",") {
        let C = S;
        const K = U[U.length - 1];
        K && Y[Y.length - 1] === "braces" && (K.comma = !0, C = "|"), F({ type: "comma", value: S, output: C });
        continue;
      }
      if (S === "/") {
        if (v.type === "dot" && m.index === m.start + 1) {
          m.start = m.index + 1, m.consumed = "", m.output = "", p.pop(), v = O;
          continue;
        }
        F({ type: "slash", value: S, output: $ });
        continue;
      }
      if (S === ".") {
        if (m.braces > 0 && v.type === "dot") {
          v.value === "." && (v.output = d);
          const C = U[U.length - 1];
          v.type = "dots", v.output += S, v.value += S, C.dots = !0;
          continue;
        }
        if (m.braces + m.parens === 0 && v.type !== "bos" && v.type !== "slash") {
          F({ type: "text", value: S, output: d });
          continue;
        }
        F({ type: "dot", value: S, output: d });
        continue;
      }
      if (S === "?") {
        if (!(v && v.value === "(") && f.noextglob !== !0 && H() === "(" && H(2) !== "?") {
          ie("qmark", S);
          continue;
        }
        if (v && v.type === "paren") {
          const K = H();
          let Z = S;
          (v.value === "(" && !/[!=<:]/.test(K) || K === "<" && !/<([!=]|\w+>)/.test(ee())) && (Z = `\\${S}`), F({ type: "text", value: S, output: Z });
          continue;
        }
        if (f.dot !== !0 && (v.type === "slash" || v.type === "bos")) {
          F({ type: "qmark", value: S, output: I });
          continue;
        }
        F({ type: "qmark", value: S, output: R });
        continue;
      }
      if (S === "!") {
        if (f.noextglob !== !0 && H() === "(" && (H(2) !== "?" || !/[!=<:]/.test(H(3)))) {
          ie("negate", S);
          continue;
        }
        if (f.nonegate !== !0 && m.index === 0) {
          te();
          continue;
        }
      }
      if (S === "+") {
        if (f.noextglob !== !0 && H() === "(" && H(2) !== "?") {
          ie("plus", S);
          continue;
        }
        if (v && v.value === "(" || f.regex === !1) {
          F({ type: "plus", value: S, output: w });
          continue;
        }
        if (v && (v.type === "bracket" || v.type === "paren" || v.type === "brace") || m.parens > 0) {
          F({ type: "plus", value: S });
          continue;
        }
        F({ type: "plus", value: w });
        continue;
      }
      if (S === "@") {
        if (f.noextglob !== !0 && H() === "(" && H(2) !== "?") {
          F({ type: "at", extglob: !0, value: S, output: "" });
          continue;
        }
        F({ type: "text", value: S });
        continue;
      }
      if (S !== "*") {
        (S === "$" || S === "^") && (S = `\\${S}`);
        const C = u.exec(ee());
        C && (S += C[0], m.index += C[0].length), F({ type: "text", value: S });
        continue;
      }
      if (v && (v.type === "globstar" || v.star === !0)) {
        v.type = "star", v.star = !0, v.value += S, v.output = N, m.backtrack = !0, m.globstar = !0, fe(S);
        continue;
      }
      let P = ee();
      if (f.noextglob !== !0 && /^\([^?]/.test(P)) {
        ie("star", S);
        continue;
      }
      if (v.type === "star") {
        if (f.noglobstar === !0) {
          fe(S);
          continue;
        }
        const C = v.prev, K = C.prev, Z = C.type === "slash" || C.type === "bos", oe = K && (K.type === "star" || K.type === "globstar");
        if (f.bash === !0 && (!Z || P[0] && P[0] !== "/")) {
          F({ type: "star", value: S, output: "" });
          continue;
        }
        const J = m.braces > 0 && (C.type === "comma" || C.type === "brace"), We = k.length && (C.type === "pipe" || C.type === "paren");
        if (!Z && C.type !== "paren" && !J && !We) {
          F({ type: "star", value: S, output: "" });
          continue;
        }
        for (; P.slice(0, 3) === "/**"; ) {
          const Ce = l[m.index + 4];
          if (Ce && Ce !== "/")
            break;
          P = P.slice(3), fe("/**", 3);
        }
        if (C.type === "bos" && ce()) {
          v.type = "globstar", v.value += S, v.output = A(f), m.output = v.output, m.globstar = !0, fe(S);
          continue;
        }
        if (C.type === "slash" && C.prev.type !== "bos" && !oe && ce()) {
          m.output = m.output.slice(0, -(C.output + v.output).length), C.output = `(?:${C.output}`, v.type = "globstar", v.output = A(f) + (f.strictSlashes ? ")" : "|$)"), v.value += S, m.globstar = !0, m.output += C.output + v.output, fe(S);
          continue;
        }
        if (C.type === "slash" && C.prev.type !== "bos" && P[0] === "/") {
          const Ce = P[1] !== void 0 ? "|$" : "";
          m.output = m.output.slice(0, -(C.output + v.output).length), C.output = `(?:${C.output}`, v.type = "globstar", v.output = `${A(f)}${$}|${$}${Ce})`, v.value += S, m.output += C.output + v.output, m.globstar = !0, fe(S + X()), F({ type: "slash", value: "/", output: "" });
          continue;
        }
        if (C.type === "bos" && P[0] === "/") {
          v.type = "globstar", v.value += S, v.output = `(?:^|${$}|${A(f)}${$})`, m.output = v.output, m.globstar = !0, fe(S + X()), F({ type: "slash", value: "/", output: "" });
          continue;
        }
        m.output = m.output.slice(0, -v.output.length), v.type = "globstar", v.output = A(f), v.value += S, m.output += v.output, m.globstar = !0, fe(S);
        continue;
      }
      const W = { type: "star", value: S, output: N };
      if (f.bash === !0) {
        W.output = ".*?", (v.type === "bos" || v.type === "slash") && (W.output = x + W.output), F(W);
        continue;
      }
      if (v && (v.type === "bracket" || v.type === "paren") && f.regex === !0) {
        W.output = S, F(W);
        continue;
      }
      (m.index === m.start || v.type === "slash" || v.type === "dot") && (v.type === "dot" ? (m.output += G, v.output += G) : f.dot === !0 ? (m.output += _, v.output += _) : (m.output += x, v.output += x), H() !== "*" && (m.output += T, v.output += T)), F(W);
    }
    for (; m.brackets > 0; ) {
      if (f.strictBrackets === !0) throw new SyntaxError(a("closing", "]"));
      m.output = s.escapeLast(m.output, "["), ue("brackets");
    }
    for (; m.parens > 0; ) {
      if (f.strictBrackets === !0) throw new SyntaxError(a("closing", ")"));
      m.output = s.escapeLast(m.output, "("), ue("parens");
    }
    for (; m.braces > 0; ) {
      if (f.strictBrackets === !0) throw new SyntaxError(a("closing", "}"));
      m.output = s.escapeLast(m.output, "{"), ue("braces");
    }
    if (f.strictSlashes !== !0 && (v.type === "star" || v.type === "bracket") && F({ type: "maybe_slash", value: "", output: `${$}?` }), m.backtrack === !0) {
      m.output = "";
      for (const P of m.tokens)
        m.output += P.output != null ? P.output : P.value, P.suffix && (m.output += P.suffix);
    }
    return m;
  };
  return c.fastpaths = (l, h) => {
    const f = { ...h }, g = typeof f.maxLength == "number" ? Math.min(i, f.maxLength) : i, b = l.length;
    if (b > g)
      throw new SyntaxError(`Input length: ${b}, exceeds maximum allowed length: ${g}`);
    l = r[l] || l;
    const {
      DOT_LITERAL: O,
      SLASH_LITERAL: p,
      ONE_CHAR: y,
      DOTS_SLASH: L,
      NO_DOT: E,
      NO_DOTS: d,
      NO_DOTS_SLASH: w,
      STAR: $,
      START_ANCHOR: T
    } = e.globChars(f.windows), B = f.dot ? d : E, M = f.dot ? w : E, G = f.capture ? "" : "?:", _ = { negated: !1, prefix: "" };
    let R = f.bash === !0 ? ".*?" : $;
    f.capture && (R = `(${R})`);
    const I = (x) => x.noglobstar === !0 ? R : `(${G}(?:(?!${T}${x.dot ? L : O}).)*?)`, q = (x) => {
      switch (x) {
        case "*":
          return `${B}${y}${R}`;
        case ".*":
          return `${O}${y}${R}`;
        case "*.*":
          return `${B}${R}${O}${y}${R}`;
        case "*/*":
          return `${B}${R}${p}${y}${M}${R}`;
        case "**":
          return B + I(f);
        case "**/*":
          return `(?:${B}${I(f)}${p})?${M}${y}${R}`;
        case "**/*.*":
          return `(?:${B}${I(f)}${p})?${M}${R}${O}${y}${R}`;
        case "**/.*":
          return `(?:${B}${I(f)}${p})?${O}${y}${R}`;
        default: {
          const D = /^(.*?)\.(\w+)$/.exec(x);
          if (!D) return;
          const N = q(D[1]);
          return N ? N + O + D[2] : void 0;
        }
      }
    }, j = s.removePrefix(l, _);
    let A = q(j);
    return A && f.strictSlashes !== !0 && (A += `${p}?`), A;
  }, Qt = c, Qt;
}
var Jt, Bn;
function bi() {
  if (Bn) return Jt;
  Bn = 1;
  const e = /* @__PURE__ */ wi(), s = /* @__PURE__ */ Si(), i = /* @__PURE__ */ Ke(), o = /* @__PURE__ */ Xe(), u = (r) => r && typeof r == "object" && !Array.isArray(r), t = (r, n, a = !1) => {
    if (Array.isArray(r)) {
      const p = r.map((L) => t(L, n, a));
      return (L) => {
        for (const E of p) {
          const d = E(L);
          if (d) return d;
        }
        return !1;
      };
    }
    const c = u(r) && r.tokens && r.input;
    if (r === "" || typeof r != "string" && !c)
      throw new TypeError("Expected pattern to be a non-empty string");
    const l = n || {}, h = l.windows, f = c ? t.compileRe(r, n) : t.makeRe(r, n, !1, !0), g = f.state;
    delete f.state;
    let b = () => !1;
    if (l.ignore) {
      const p = { ...n, ignore: null, onMatch: null, onResult: null };
      b = t(l.ignore, p, a);
    }
    const O = (p, y = !1) => {
      const { isMatch: L, match: E, output: d } = t.test(p, f, n, { glob: r, posix: h }), w = { glob: r, state: g, regex: f, posix: h, input: p, output: d, match: E, isMatch: L };
      return typeof l.onResult == "function" && l.onResult(w), L === !1 ? (w.isMatch = !1, y ? w : !1) : b(p) ? (typeof l.onIgnore == "function" && l.onIgnore(w), w.isMatch = !1, y ? w : !1) : (typeof l.onMatch == "function" && l.onMatch(w), y ? w : !0);
    };
    return a && (O.state = g), O;
  };
  return t.test = (r, n, a, { glob: c, posix: l } = {}) => {
    if (typeof r != "string")
      throw new TypeError("Expected input to be a string");
    if (r === "")
      return { isMatch: !1, output: "" };
    const h = a || {}, f = h.format || (l ? i.toPosixSlashes : null);
    let g = r === c, b = g && f ? f(r) : r;
    return g === !1 && (b = f ? f(r) : r, g = b === c), (g === !1 || h.capture === !0) && (h.matchBase === !0 || h.basename === !0 ? g = t.matchBase(r, n, a, l) : g = n.exec(b)), { isMatch: !!g, match: g, output: b };
  }, t.matchBase = (r, n, a) => (n instanceof RegExp ? n : t.makeRe(n, a)).test(i.basename(r)), t.isMatch = (r, n, a) => t(n, a)(r), t.parse = (r, n) => Array.isArray(r) ? r.map((a) => t.parse(a, n)) : s(r, { ...n, fastpaths: !1 }), t.scan = (r, n) => e(r, n), t.compileRe = (r, n, a = !1, c = !1) => {
    if (a === !0)
      return r.output;
    const l = n || {}, h = l.contains ? "" : "^", f = l.contains ? "" : "$";
    let g = `${h}(?:${r.output})${f}`;
    r && r.negated === !0 && (g = `^(?!${g}).*$`);
    const b = t.toRegex(g, n);
    return c === !0 && (b.state = r), b;
  }, t.makeRe = (r, n = {}, a = !1, c = !1) => {
    if (!r || typeof r != "string")
      throw new TypeError("Expected a non-empty string");
    let l = { negated: !1, fastpaths: !0 };
    return n.fastpaths !== !1 && (r[0] === "." || r[0] === "*") && (l.output = s.fastpaths(r, n)), l.output || (l = s(r, n)), t.compileRe(l, n, a, c);
  }, t.toRegex = (r, n) => {
    try {
      const a = n || {};
      return new RegExp(r, a.flags || (a.nocase ? "i" : ""));
    } catch (a) {
      if (n && n.debug === !0) throw a;
      return /$^/;
    }
  }, t.constants = o, Jt = t, Jt;
}
var er, Mn;
function Oi() {
  if (Mn) return er;
  Mn = 1;
  const e = /* @__PURE__ */ bi(), s = /* @__PURE__ */ Ke();
  function i(o, u, t = !1) {
    return u && (u.windows === null || u.windows === void 0) && (u = { ...u, windows: s.isWindows() }), e(o, u, t);
  }
  return Object.assign(i, e), er = i, er;
}
var _i = /* @__PURE__ */ Oi();
const Fn = /* @__PURE__ */ Ge(_i), Ti = "16.4.1", Ii = {
  version: Ti
}, xi = /^.*?:\/\/(.*?@)?(github\.com[:/])/i, Ci = /^([^/]+)\/([^/#]+)?.*?\/([0-9a-f]+|v?[0-9]+\.[0-9]+\.[0-9]+)$/i, sr = /^[0-9a-f]{7,}$/i, Un = /[0-9]+(\.[0-9]+)?(\.[0-9]+)?/g, He = (e) => e.replace(/[|\\{}()[\]^$+*?.-]/g, "\\$&"), Ie = (e) => e.endsWith("/") ? e.substring(0, e.length - 1) : e, cs = Ii.version, de = "\0", ir = {
  "package.json": "npm",
  "pyproject.toml": "pypi",
  "go.mod": "go"
}, z = Is(Rs.slice(2), {
  boolean: [
    "E",
    "error-on-outdated",
    "U",
    "error-on-unchanged",
    "h",
    "help",
    "j",
    "json",
    "n",
    "no-color",
    "u",
    "update",
    "v",
    "version",
    "V",
    "verbose"
  ],
  string: [
    "d",
    "allow-downgrade",
    "f",
    "file",
    "g",
    "greatest",
    "m",
    "minor",
    "M",
    "modes",
    "P",
    "patch",
    "p",
    "prerelease",
    "R",
    "release",
    "r",
    "registry",
    "t",
    "types",
    "githubapi",
    // undocumented, only for tests
    "pypiapi",
    // undocumented, only for tests
    "goproxy"
    // undocumented, only for tests
  ],
  alias: {
    d: "allow-downgrade",
    E: "error-on-outdated",
    U: "error-on-unchanged",
    e: "exclude",
    f: "file",
    g: "greatest",
    h: "help",
    i: "include",
    j: "json",
    m: "minor",
    M: "modes",
    n: "no-color",
    P: "patch",
    p: "prerelease",
    r: "registry",
    R: "release",
    s: "semver",
    S: "sockets",
    t: "types",
    u: "update",
    v: "version",
    V: "verbose"
  }
});
(z["no-color"] || !vi.stdout) && Ri();
const Ae = xe(ve(z.greatest)), tr = xe(ve(z.prerelease)), rr = xe(ve(z.release)), kn = xe(ve(z.patch)), Vn = xe(ve(z.minor)), Xn = ve(z["allow-downgrade"]), Li = ve(z.modes) || /* @__PURE__ */ new Set(["npm", "pypi"]), ls = z.githubapi ? Ie(z.githubapi) : "https://api.github.com", Ni = z.pypiapi ? Ie(z.pypiapi) : "https://pypi.org", Pi = "https://proxy.golang.org", Di = z.goproxy ? Ie(z.goproxy) : Hi(), Se = (e) => e.replace(/^v/, "");
function ye(e, s) {
  for (const i of s instanceof Set ? s : [])
    if (i.test(e)) return !0;
  return !1;
}
function qi(e, s) {
  const i = s[`${e}:registry`] || s.registry;
  return i.endsWith("/") ? i : `${i}/`;
}
function Hi() {
  return we.GOPROXY ? we.GOPROXY.split(/[,|]/).map((e) => e.trim()).filter((e) => !!e && e !== "direct") : [Pi];
}
function ji(e, s) {
  return s.split(".").reduce((i, o) => i?.[o] ?? null, e);
}
function De(e) {
  return e.split(",").filter(Boolean);
}
function fs(e, s) {
  const i = lr(s, e);
  try {
    return Ss(i), i;
  } catch {
  }
  const o = cr(s);
  return o === s ? null : fs(e, o);
}
function Gi(e, s, i, o) {
  if (e.startsWith("@")) {
    const u = (/@[a-z0-9][\w-.]+/.exec(e) || [""])[0], t = Ie(qi(u, o));
    if (t !== s)
      try {
        const r = rt(t, i);
        if (r?.token) return { auth: r, registry: t };
      } catch {
      }
    return { auth: rt(s, i), registry: s };
  } else
    return { auth: rt(s, i), registry: s };
}
function yr(e, s, i) {
  return {
    ...Object.keys(e).length && { agentOpts: e },
    headers: {
      "user-agent": `updates/${cs}`,
      ...i && { Authorization: `${s} ${i}` }
    }
  };
}
async function ze(e, s) {
  z.verbose && console.error(`${yi("fetch")} ${e}`);
  const i = await fetch(e, s);
  return z.verbose && console.error(`${i.ok ? Rr(i.status) : vr(i.status)} ${e}`), i;
}
async function Bi(e, s, i, o, u, t) {
  const { auth: r, registry: n } = Gi(e, i, u, t), a = s === "resolutions" ? Pe(e) : e, c = `${n}/${a.replace(/\//g, "%2f")}`, l = await ze(c, yr(o, r?.type, r?.token));
  if (l?.ok)
    return [await l.json(), s, n, e];
  throw l?.status && l?.statusText ? new Error(`Received ${l.status} ${l.statusText} from ${c}`) : new Error(`Unable to fetch ${e} from ${n}`);
}
async function Mi(e, s, i) {
  const o = `${Ni}/pypi/${e}/json`, u = await ze(o, yr(i));
  if (u?.ok)
    return [await u.json(), s, null, e];
  throw u?.status && u?.statusText ? new Error(`Received ${u.status} ${u.statusText} from ${o}`) : new Error(`Unable to fetch ${e} from PyPi`);
}
function Fi(e) {
  return e.split(/\r?\n/).map((s) => s.trim()).filter(Boolean);
}
async function hs(e, s, i, o) {
  const u = o.shift();
  if (!u)
    throw new Error("No more go proxies available");
  const t = `${u}/${e.toLowerCase()}/@latest`, r = await ze(t, yr(i));
  if ([404, 410].includes(r.status) && o.length)
    return hs(e, s, i, o);
  if (r?.ok)
    return r.json();
  throw r?.status && r?.statusText ? new Error(`Received ${r.status} ${r.statusText} from ${t}`) : new Error(`Unable to fetch ${e} from PyPi`);
}
function Ui(e) {
  return e = e.replace("git@", "").replace(/.+?\/\//, "https://").replace(/\.git$/, ""), /^[a-z]+:[a-z0-9-]\/[a-z0-9-]$/.test(e) ? e.replace(/^(.+?):/, (s, i) => `https://${i}.com/`) : /^[a-z0-9-]\/[a-z0-9-]$/.test(e) ? `https://github.com/${e}` : e;
}
function ki(e) {
  return e.startsWith("https://bitbucket.org") ? "src/HEAD" : "tree/HEAD";
}
function Kn({ repository: e, homepage: s, info: i }, o, u) {
  i && (e = i.project_urls.repository || i.project_urls.Repository || i.project_urls.repo || i.project_urls.Repo || i.project_urls.source || i.project_urls.Source || i.project_urls["source code"] || i.project_urls["Source code"] || i.project_urls["Source Code"] || i.project_urls.homepage || i.project_urls.Homepage || `https://pypi.org/project/${u}/`);
  let t = "";
  if (o === "https://npm.pkg.github.com")
    return `https://github.com/${u.replace(/^@/, "")}`;
  if (e) {
    const r = typeof e == "string" ? e : e.url;
    t = Ui(r), t && typeof e != "string" && e.directory && (t = `${t}/${ki(t)}/${e.directory}`);
  }
  return t || s || "";
}
function zn(e) {
  console.info(z.json ? JSON.stringify({ message: e }) : e), _e();
}
function _e(e) {
  if (e) {
    const s = e.stack ?? e.message;
    console.info(z.json ? JSON.stringify({ error: s }) : vr(s));
  }
  process.exit(e ? 1 : 0);
}
function Vi(e = {}) {
  for (const i of Object.keys(e))
    for (const o of Object.values(e[i]))
      typeof o.oldPrint == "string" && (o.old = o.oldPrint, delete o.oldPrint), typeof o.newPrint == "string" && (o.new = o.newPrint, delete o.newPrint), typeof o.oldOriginal == "string" && (o.old = o.oldOriginal, delete o.oldOriginal);
  let s = 0;
  for (const i of Object.keys(e))
    s += Object.keys(e[i]).length;
  if (z.json) {
    const i = { results: {} };
    for (const o of Object.keys(e))
      for (const [u, t] of Object.entries(e[o])) {
        const [r, n] = u.split(de);
        i.results[o] || (i.results[o] = {}), i.results[o][r] || (i.results[o][r] = {}), i.results[o][r][n] = t;
      }
    console.info(JSON.stringify(i));
  } else s && console.info(Wi(e));
  return z["error-on-outdated"] ? s ? 2 : 0 : z["error-on-unchanged"] ? s ? 0 : 2 : 0;
}
async function Xi(e, s) {
  const { platform: i } = await import("node:os"), o = i() === "win32";
  o && As(e, 0), ws(e, s, o ? { flag: "r+" } : void 0);
}
function Wn(e, s, i) {
  if (e === s) return e;
  const o = e.split(/\./), u = s.split(/\./), t = /^[0-9a-zA-Z-.]+$/;
  let r = "";
  for (let n = 0; n < o.length; n++)
    if (o[n] !== u[n]) {
      t.test(o[n]) ? r += i(o.slice(n).join(".")) : r += o[n].split("").map((a) => t.test(a) ? i(a) : a).join("") + i(`.${o.slice(n + 1).join(".")}`.replace(/\.$/, ""));
      break;
    } else
      r += `${o[n]}.`;
  return r.replace(/\.$/, "");
}
const Yn = (e) => bs(e).length;
function Ki(e, s = " ") {
  let i = "";
  const o = new Array(e[0].length).fill(0);
  for (const u of e)
    for (const [t, r] of u.entries()) {
      const n = Yn(r);
      n > o[t] && (o[t] = n);
    }
  for (const [u, t] of e.entries()) {
    for (const [r, n] of t.entries()) {
      r > 0 && (i += s);
      const a = " ".repeat(o[r] - Yn(n));
      i += n + (r === t.length - 1 ? "" : a);
    }
    u < e.length - 1 && (i += `
`);
  }
  return i;
}
function zi(e) {
  return /\/v[0-9]$/.test(e) && (e = cr(e)), e;
}
function Wi(e) {
  const s = [["NAME", "OLD", "NEW", "AGE", "INFO"]], i = /* @__PURE__ */ new Set();
  for (const o of Object.keys(e))
    for (const [u, t] of Object.entries(e[o])) {
      const r = u.split(de)[1], n = `${o}|${r}`;
      i.has(n) || (i.add(n), s.push([
        o === "go" ? zi(r) : r,
        Wn(t.old, t.new, vr),
        Wn(t.new, t.old, Rr),
        t.age || "",
        t.info || ""
      ]));
    }
  return Ki(s);
}
function Yi(e, s) {
  let i = e;
  for (const o of Object.keys(s)) {
    const u = o.split(de)[1], t = s[o].oldOriginal || s[o].old, r = new RegExp(`"${He(u)}": *"${He(t)}"`, "g");
    i = i.replace(r, `"${u}": "${s[o].new}"`);
  }
  return i;
}
function Zi(e, s) {
  let i = e;
  for (const o of Object.keys(s)) {
    const u = o.split(de)[1], t = s[o].oldOriginal || s[o].old, r = new RegExp(`${He(u)} *= *"${He(t)}"`, "g");
    i = i.replace(r, `${u} = "${s[o].new}"`);
  }
  return i;
}
function Qi(e, s, i) {
  let o = e.replace(/[0-9]+\.[0-9]+\.[0-9]+(-.+)?/g, s);
  if (i && i !== e && /^[\^~]/.test(o)) {
    const u = i.substring(1).split("."), t = o.substring(1).split(".");
    u.length !== t.length && (o = `${o[0]}${t.slice(0, u.length).join(".")}`);
  }
  return o;
}
function nr(e) {
  const s = re.parse(e);
  return s ? !!s.prerelease.length : !1;
}
function ps(e) {
  return /[0-9]+\.[0-9]+\.[0-9]+-.+/.test(e);
}
function Te(e) {
  try {
    return re.coerce(e)?.version ?? "";
  } catch {
    return "";
  }
}
function Ji(e, s, { range: i, semvers: o, usePre: u, useRel: t, useGreatest: r }) {
  let n = Te(i), a = 0;
  u = ps(i) || u, u && (o.add("prerelease"), o.has("patch") && o.add("prepatch"), o.has("minor") && o.add("preminor"), o.has("major") && o.add("premajor"));
  for (const c of s) {
    const l = re.parse(c);
    if (!l || !n || l.prerelease.length && (!u || t)) continue;
    const h = re.diff(n, l.version);
    if (!(!h || !o.has(h)))
      if (r || !("time" in e))
        re.gte(Te(l?.version), n) && (n = l.version);
      else {
        const f = new Date(e.time[c]).getTime();
        f >= 0 && f > a && (n = l.version, a = f);
      }
  }
  return n || null;
}
function eo(e, { mode: s, range: i, useGreatest: o, useRel: u, usePre: t, semvers: r }) {
  if (s === "go")
    return re.gt(Se(e.Version), Se(i)) ? e.Version : null;
  if (i === "*" || i.includes("||")) return null;
  let n = [];
  s === "pypi" ? n = Object.keys(e.releases).filter((c) => re.valid(c)) : s === "npm" && (n = Object.keys(e.versions).filter((c) => re.valid(c)));
  const a = Ji(e, n, { range: i, semvers: r, usePre: t, useRel: u, useGreatest: o });
  if (!a) return null;
  if (o)
    return a;
  {
    let c = "", l = "";
    s === "pypi" ? (l = e.info.version, c = Te(e.info.version)) : c = e["dist-tags"].latest;
    const h = Te(i), f = ps(i), g = nr(a), b = nr(c), O = re.gt(a, h);
    if (!u && t || f && g || u && !O && f && !g || f && !g && O)
      return a;
    if (f && !g && !O)
      return null;
    const p = re.diff(h, c);
    return p && p !== "prerelease" && !r.has(p.replace(/^pre/, "")) || u && nr(c) ? a : re.lt(c, h) && !b ? Xn === !0 || ye(e.name, Xn) ? c : null : l || c;
  }
}
function ds(e) {
  const s = {}, i = we.UPDATES_GITHUB_API_TOKEN || we.GITHUB_API_TOKEN || we.GH_TOKEN || we.HOMEBREW_GITHUB_API_TOKEN;
  return i && (s.headers = { Authorization: `Bearer ${i}` }), ze(e, s);
}
async function to(e, s) {
  const i = `${ls}/repos/${e}/${s}/commits`, o = await ds(i);
  if (!o?.ok) return { hash: "", commit: {} };
  const u = await o.json(), { sha: t, commit: r } = u[0];
  return { hash: t, commit: r };
}
async function ro(e, s) {
  const i = await ds(`${ls}/repos/${e}/${s}/git/refs/tags`);
  return i?.ok ? (await i.json()).map((t) => t.ref.replace(/^refs\/tags\//, "")) : [];
}
function no(e, s, i) {
  const o = Se(s);
  if (re.valid(o))
    if (i) {
      let u = s, t = Se(s);
      for (const r of e) {
        const n = Se(r);
        re.valid(n) && (!u || re.gt(n, t)) && (u = r, t = n);
      }
      if (re.neq(o, t))
        return u;
    } else {
      const u = e.at(-1);
      if (!u) return;
      const t = Se(u);
      if (!re.valid(t)) return;
      if (re.neq(o, t))
        return u;
    }
}
async function so(e, s, i) {
  const o = s.old.replace(xi, ""), [u, t, r, n] = Ci.exec(o) || [];
  if (!(!t || !r || !n))
    if (sr.test(n)) {
      const { hash: a, commit: c } = await to(t, r);
      if (!a) return;
      const l = c?.committer?.date ?? c?.author?.date, h = a.substring(0, n.length);
      if (n !== h) {
        const f = s.old.replace(n, h);
        return { key: e, newRange: f, user: t, repo: r, oldRef: n, newRef: h, newDate: l };
      }
    } else {
      const a = await ro(t, r), c = no(a, n, i);
      if (c)
        return { key: e, newRange: c, user: t, repo: r, oldRef: n, newRef: c };
    }
}
function io(e) {
  return e.replace(/-.*/, "");
}
function oo(e) {
  const s = e.match(Un);
  return s?.length !== 1 ? e : e.replace(Un, Te(s[0]));
}
function ve(e) {
  return e === void 0 ? !1 : e === "" ? !0 : typeof e == "string" ? e.includes(",") ? new Set(De(e)) : /* @__PURE__ */ new Set([e]) : Array.isArray(e) ? new Set(e) : !1;
}
function ao(e) {
  return Array.from(e.matchAll(/(----BEGIN CERT[^]+?IFICATE----)/g), (s) => s[0]);
}
function uo(e) {
  return Array.from(e.matchAll(/(----BEGIN [^]+?PRIVATE KEY----)/g), (s) => s[0]);
}
async function co(e = []) {
  return [...(await import("node:tls")).rootCertificates, ...e];
}
function or(e, s) {
  return s && typeof e == "string" ? /\/.+\//.test(e) ? new RegExp(e.slice(1, -1)) : Fn.makeRe(e) : e instanceof RegExp ? e : Fn.makeRe(e);
}
function xe(e) {
  if (e instanceof Set) {
    const s = /* @__PURE__ */ new Set();
    for (const i of e)
      s.add(or(i, !0));
    return s;
  }
  return e;
}
function Zn(e, s) {
  const i = /* @__PURE__ */ new Set();
  for (const o of e || [])
    i.add(or(o, !0));
  for (const o of s || [])
    i.add(or(o, !1));
  return i;
}
function Qn(e, s, i, o) {
  if (s === "pypi" && e === "python") return !1;
  if (!i.size && !o.size) return !0;
  for (const u of o)
    if (u.test(e)) return !1;
  for (const u of i)
    if (u.test(e)) return !0;
  return !i.size;
}
function lo(e) {
  const s = /* @__PURE__ */ new Set(), i = /* @__PURE__ */ new Set();
  if (e)
    for (const o of e) {
      let u;
      try {
        u = br(o);
      } catch (t) {
        throw new Error(`Unable to open ${o}: ${t.message}`);
      }
      if (u?.isFile()) {
        const t = Ne(o);
        s.add(t), i.add(t);
      } else if (u?.isDirectory())
        for (const t of Object.keys(ir)) {
          const r = lr(o, t);
          let n;
          try {
            n = br(r);
          } catch {
          }
          n?.isFile() && s.add(Ne(r));
        }
      else
        throw new Error(`${o} is neither a file nor directory`);
    }
  else
    for (const o of Object.keys(ir)) {
      const u = fs(o, $s());
      u && s.add(Ne(u));
    }
  return [s, i];
}
async function fo(e) {
  const s = [];
  for (const o of ["", ".config/"])
    for (const u of ["js", "ts", "mjs", "mts"])
      s.push(`${o}updates${o ? "" : ".config"}.${u}`);
  let i = {};
  try {
    ({ default: i } = await Promise.any(s.map((o) => import(lr(e, ...o.split("/"))))));
  } catch {
  }
  return i;
}
async function ho() {
  for (const p of [process.stdout, process.stderr])
    p?._handle?.setBlocking?.(!0);
  const e = 96, s = typeof z.sockets == "number" ? z.sockets : e, { help: i, version: o, file: u, types: t, update: r } = z;
  i && (ys.write(`usage: updates [options]

  Options:
    -u, --update                       Update versions and write package file
    -f, --file <path,...>              File or directory to use, defaults to current directory
    -i, --include <pkg,...>            Include only given packages
    -e, --exclude <pkg,...>            Exclude given packages
    -p, --prerelease [<pkg,...>]       Consider prerelease versions
    -R, --release [<pkg,...>]          Only use release versions, may downgrade
    -g, --greatest [<pkg,...>]         Prefer greatest over latest version
    -t, --types <type,...>             Check only given dependency types
    -P, --patch [<pkg,...>]            Consider only up to semver-patch
    -m, --minor [<pkg,...>]            Consider only up to semver-minor
    -d, --allow-downgrade [<pkg,...>]  Allow version downgrades when using latest version
    -E, --error-on-outdated            Exit with code 2 when updates are available and 0 when not
    -U, --error-on-unchanged           Exit with code 0 when updates are available and 2 when not
    -r, --registry <url>               Override npm registry URL
    -S, --sockets <num>                Maximum number of parallel HTTP sockets opened. Default: ${e}
    -M, --modes <mode,...>             Which modes to enable. Either npm,pypi,go. Default: npm,pypi
    -j, --json                         Output a JSON object
    -n, --no-color                     Disable color output
    -v, --version                      Print the version
    -V, --verbose                      Print verbose output to stderr
    -h, --help                         Print this help

  Examples:
    $ updates
    $ updates -u
    $ updates -e '@vitejs/*'
    $ updates -e '/^react-(dom)?/'
    $ updates -f package.json
    $ updates -f pyproject.toml
`), wr(0)), o && (console.info(cs), wr(0));
  const n = {}, a = {}, c = {}, l = {};
  let h = 0;
  const [f, g] = lo(ve(u));
  for (const p of f) {
    const y = cr(Ne(p)), L = Pe(p), E = ir[L];
    if (!Li.has(E) && !g.has(p)) continue;
    l[E] = p, n[E] || (n[E] = {});
    const d = await fo(y);
    let w = [], $ = [];
    z.include && z.include !== !0 && (w = (Array.isArray(z.include) ? z.include : [z.include]).flatMap((A) => De(A))), z.exclude && z.exclude !== !0 && ($ = (Array.isArray(z.exclude) ? z.exclude : [z.exclude]).flatMap((A) => De(A)));
    const T = Zn(w, d?.include ?? []), B = Zn($, d?.exclude ?? []), M = {}, G = js("npm", { registry: "https://registry.npmjs.org" }) || {}, _ = { npmrc: G, recursive: !0 };
    if (E === "npm") {
      G["strict-ssl"] === !1 && (M.rejectUnauthorized = !1);
      for (const A of ["cert", "ca", "key"]) {
        const x = A === "key" ? uo : ao;
        let D = [];
        G[A] && (D = (Array.isArray(G[A]) ? G[A] : [G[A]]).flatMap((N) => x(N))), G[`${A}file`] && (D = Array.from(x(Sr(G[`opt${p}`], "utf8")))), D.length && (M[A] = A === "ca" ? await co(D) : D);
      }
    }
    let R = [];
    t ? R = Array.isArray(t) ? t : De(t) : "types" in d && Array.isArray(d.types) ? R = d.types : E === "npm" ? R = [
      "dependencies",
      "devDependencies",
      "optionalDependencies",
      "peerDependencies",
      "resolutions"
    ] : E === "pypi" ? R = [
      "tool.poetry.dependencies",
      "tool.poetry.dev-dependencies",
      "tool.poetry.test-dependencies",
      "tool.poetry.group.dev.dependencies",
      "tool.poetry.group.test.dependencies"
    ] : E === "go" && (R = [
      "deps"
    ]);
    let I = {};
    if (E === "go")
      c[E] = _s("go", [
        "list",
        "-m",
        "-f",
        "{{if not .Indirect}}{{.Path}}@{{.Version}}{{end}}",
        "all"
      ], { stdio: "pipe", encoding: "utf8", cwd: y });
    else
      try {
        c[E] = Sr(p, "utf8");
      } catch (A) {
        throw new Error(`Unable to open ${p}: ${A.message}`);
      }
    try {
      if (E === "npm")
        I = JSON.parse(c[E]);
      else if (E === "pypi")
        I = (await Promise.resolve().then(() => _o)).parse(c[E]);
      else {
        I.deps = {};
        for (const A of Fi(c[E])) {
          const [x, D] = A.split("@");
          D && (I.deps[x] = D);
        }
      }
    } catch (A) {
      throw new Error(`Error parsing ${p}: ${A.message}`);
    }
    for (const A of R) {
      let x;
      E === "npm" || E === "go" ? x = I[A] || {} : x = ji(I, A) || {};
      for (const [D, N] of Object.entries(x))
        E !== "go" && re.validRange(N) && Qn(D, E, T, B) ? n[E][`${A}${de}${D}`] = {
          old: oo(N),
          oldOriginal: N
        } : E === "npm" && Qn(D, E, T, B) ? a[`${A}${de}${D}`] = {
          old: N
        } : E === "go" && (n[E][`${A}${de}${D}`] = {
          old: io(N),
          oldOriginal: N
        });
    }
    if (h += Object.keys(n[E]).length + Object.keys(a).length, !h) continue;
    let q;
    E === "npm" && (q = Ie(z.registry || d.registry || G.registry));
    const j = await Dn(Object.keys(n[E]).map((A) => async () => {
      const [x, D] = A.split(de);
      if (E === "npm")
        return Bi(D, x, q, M, _, G);
      if (E === "pypi")
        return Mi(D, x, M);
      {
        const N = Array.from(Di);
        return [await hs(D, "latest", M, N), "deps", null, D];
      }
    }), { concurrency: s });
    for (const [A, x, D, N] of j) {
      if (A?.error) throw new Error(A.error);
      const m = typeof Ae == "boolean" ? Ae : ye(A.name, Ae), k = typeof tr == "boolean" ? tr : ye(A.name, tr), U = typeof rr == "boolean" ? rr : ye(A.name, rr);
      let Y;
      kn === !0 || ye(A.name, kn) ? Y = /* @__PURE__ */ new Set(["patch"]) : Vn === !0 || ye(A.name, Vn) ? Y = /* @__PURE__ */ new Set(["patch", "minor"]) : Y = /* @__PURE__ */ new Set(["patch", "minor", "major"]);
      const v = `${x}${de}${N}`, S = n[E][v].old, ce = n[E][v].oldOriginal, H = eo(A, {
        usePre: k,
        useRel: U,
        useGreatest: m,
        semvers: Y,
        range: S,
        mode: E
      });
      let X = "";
      if (E === "go" && H ? X = H : H && (X = Qi(S, H, ce)), !H || ce && ce === X)
        delete n[E][v];
      else {
        n[E][v].new = X, E === "npm" ? n[E][v].info = Kn(A?.versions?.[H], D, A.name) : E === "pypi" ? n[E][v].info = Kn(A, D, A.info.name) : n[E][v].info = A?.Origin?.URL ?? `https://${N}`;
        let ee = "";
        E === "npm" && A.time?.[H] ? ee = A.time[H] : E === "pypi" && A.releases?.[H]?.[0]?.upload_time_iso_8601 ? ee = A.releases[H][0].upload_time_iso_8601 : E === "go" && A.Time && (ee = A.Time), ee && (n[E][v].age = xn(ee, { noAffix: !0 }));
      }
    }
    if (Object.keys(a).length) {
      const A = await Dn(Object.entries(a).map(([x, D]) => () => {
        const N = x.split(de)[1], m = typeof Ae == "boolean" ? Ae : ye(N, Ae);
        return so(x, D, m);
      }), { concurrency: s });
      for (const x of (A || []).filter(Boolean)) {
        const { key: D, newRange: N, user: m, repo: k, oldRef: U, newRef: Y, newDate: v } = x;
        n[E][D] = {
          // @ts-expect-error
          old: a[D].old,
          new: N,
          oldPrint: sr.test(U) ? U.substring(0, 7) : U,
          newPrint: sr.test(Y) ? Y.substring(0, 7) : Y,
          info: `https://github.com/${m}/${k}`,
          ...v ? { age: xn(v, { noAffix: !0 }) } : {}
        };
      }
    }
  }
  h === 0 && (zn("No dependencies found, nothing to do."), _e());
  let b = 0;
  for (const p of Object.keys(n))
    b += Object.keys(n[p]).length;
  b || (zn("All dependencies are up to date."), _e());
  const O = Vi(n);
  if (r) {
    for (const p of Object.keys(n))
      if (Object.keys(n[p]).length) {
        try {
          const y = p === "npm" ? Yi : Zi;
          await Xi(l[p], y(c[p], n[p]));
        } catch (y) {
          throw new Error(`Error writing ${Pe(l[p])}: ${y.message}`);
        }
        console.info(Rr(`✨ ${Pe(l[p])} updated`));
      }
  }
  process.exit(O);
}
ho().catch(_e).then(_e);
function po(e, s) {
  let i = e.slice(0, s).split(/\r\n|\n|\r/g);
  return [i.length, i.pop().length + 1];
}
function go(e, s, i) {
  let o = e.split(/\r\n|\n|\r/g), u = "", t = (Math.log10(s + 1) | 0) + 1;
  for (let r = s - 1; r <= s + 1; r++) {
    let n = o[r - 1];
    n && (u += r.toString().padEnd(t, " "), u += ":  ", u += n, u += `
`, r === s && (u += " ".repeat(t + i + 2), u += `^
`));
  }
  return u;
}
class V extends Error {
  line;
  column;
  codeblock;
  constructor(s, i) {
    const [o, u] = po(i.toml, i.ptr), t = go(i.toml, o, u);
    super(`Invalid TOML document: ${s}

${t}`, i), this.line = o, this.column = u, this.codeblock = t;
  }
}
function je(e, s = 0, i = e.length) {
  let o = e.indexOf(`
`, s);
  return e[o - 1] === "\r" && o--, o <= i ? o : -1;
}
function $r(e, s) {
  for (let i = s; i < e.length; i++) {
    let o = e[i];
    if (o === `
`)
      return i;
    if (o === "\r" && e[i + 1] === `
`)
      return i + 1;
    if (o < " " && o !== "	" || o === "")
      throw new V("control characters are not allowed in comments", {
        toml: e,
        ptr: s
      });
  }
  return e.length;
}
function ge(e, s, i, o) {
  let u;
  for (; (u = e[s]) === " " || u === "	" || !i && (u === `
` || u === "\r" && e[s + 1] === `
`); )
    s++;
  return o || u !== "#" ? s : ge(e, $r(e, s), i);
}
function Jn(e, s, i, o, u = !1) {
  if (!o)
    return s = je(e, s), s < 0 ? e.length : s;
  for (let t = s; t < e.length; t++) {
    let r = e[t];
    if (r === "#")
      t = je(e, t);
    else {
      if (r === i)
        return t + 1;
      if (r === o)
        return t;
      if (u && (r === `
` || r === "\r" && e[t + 1] === `
`))
        return t;
    }
  }
  throw new V("cannot find end of structure", {
    toml: e,
    ptr: s
  });
}
function gs(e, s) {
  let i = e[s], o = i === e[s + 1] && e[s + 1] === e[s + 2] ? e.slice(s, s + 3) : i;
  s += o.length - 1;
  do
    s = e.indexOf(o, ++s);
  while (s > -1 && i !== "'" && e[s - 1] === "\\" && e[s - 2] !== "\\");
  return s > -1 && (s += o.length, o.length > 1 && (e[s] === i && s++, e[s] === i && s++)), s;
}
let mo = /^(\d{4}-\d{2}-\d{2})?[T ]?(?:(\d{2}):\d{2}:\d{2}(?:\.\d+)?)?(Z|[-+]\d{2}:\d{2})?$/i;
class $e extends Date {
  #t = !1;
  #r = !1;
  #e = null;
  constructor(s) {
    let i = !0, o = !0, u = "Z";
    if (typeof s == "string") {
      let t = s.match(mo);
      t ? (t[1] || (i = !1, s = `0000-01-01T${s}`), o = !!t[2], t[2] && +t[2] > 23 ? s = "" : (u = t[3] || null, s = s.toUpperCase(), !u && o && (s += "Z"))) : s = "";
    }
    super(s), isNaN(this.getTime()) || (this.#t = i, this.#r = o, this.#e = u);
  }
  isDateTime() {
    return this.#t && this.#r;
  }
  isLocal() {
    return !this.#t || !this.#r || !this.#e;
  }
  isDate() {
    return this.#t && !this.#r;
  }
  isTime() {
    return this.#r && !this.#t;
  }
  isValid() {
    return this.#t || this.#r;
  }
  toISOString() {
    let s = super.toISOString();
    if (this.isDate())
      return s.slice(0, 10);
    if (this.isTime())
      return s.slice(11, 23);
    if (this.#e === null)
      return s.slice(0, -1);
    if (this.#e === "Z")
      return s;
    let i = +this.#e.slice(1, 3) * 60 + +this.#e.slice(4, 6);
    return i = this.#e[0] === "-" ? i : -i, new Date(this.getTime() - i * 6e4).toISOString().slice(0, -1) + this.#e;
  }
  static wrapAsOffsetDateTime(s, i = "Z") {
    let o = new $e(s);
    return o.#e = i, o;
  }
  static wrapAsLocalDateTime(s) {
    let i = new $e(s);
    return i.#e = null, i;
  }
  static wrapAsLocalDate(s) {
    let i = new $e(s);
    return i.#r = !1, i.#e = null, i;
  }
  static wrapAsLocalTime(s) {
    let i = new $e(s);
    return i.#t = !1, i.#e = null, i;
  }
}
let Eo = /^((0x[0-9a-fA-F](_?[0-9a-fA-F])*)|(([+-]|0[ob])?\d(_?\d)*))$/, vo = /^[+-]?\d(_?\d)*(\.\d(_?\d)*)?([eE][+-]?\d(_?\d)*)?$/, Ro = /^[+-]?0[0-9_]/, yo = /^[0-9a-f]{4,8}$/i, es = {
  b: "\b",
  t: "	",
  n: `
`,
  f: "\f",
  r: "\r",
  '"': '"',
  "\\": "\\"
};
function ms(e, s = 0, i = e.length) {
  let o = e[s] === "'", u = e[s++] === e[s] && e[s] === e[s + 1];
  u && (i -= 2, e[s += 2] === "\r" && s++, e[s] === `
` && s++);
  let t = 0, r, n = "", a = s;
  for (; s < i - 1; ) {
    let c = e[s++];
    if (c === `
` || c === "\r" && e[s] === `
`) {
      if (!u)
        throw new V("newlines are not allowed in strings", {
          toml: e,
          ptr: s - 1
        });
    } else if (c < " " && c !== "	" || c === "")
      throw new V("control characters are not allowed in strings", {
        toml: e,
        ptr: s - 1
      });
    if (r) {
      if (r = !1, c === "u" || c === "U") {
        let l = e.slice(s, s += c === "u" ? 4 : 8);
        if (!yo.test(l))
          throw new V("invalid unicode escape", {
            toml: e,
            ptr: t
          });
        try {
          n += String.fromCodePoint(parseInt(l, 16));
        } catch {
          throw new V("invalid unicode escape", {
            toml: e,
            ptr: t
          });
        }
      } else if (u && (c === `
` || c === " " || c === "	" || c === "\r")) {
        if (s = ge(e, s - 1, !0), e[s] !== `
` && e[s] !== "\r")
          throw new V("invalid escape: only line-ending whitespace may be escaped", {
            toml: e,
            ptr: t
          });
        s = ge(e, s);
      } else if (c in es)
        n += es[c];
      else
        throw new V("unrecognized escape sequence", {
          toml: e,
          ptr: t
        });
      a = s;
    } else !o && c === "\\" && (t = s - 1, r = !0, n += e.slice(a, t));
  }
  return n + e.slice(a, i - 1);
}
function $o(e, s, i) {
  if (e === "true")
    return !0;
  if (e === "false")
    return !1;
  if (e === "-inf")
    return -1 / 0;
  if (e === "inf" || e === "+inf")
    return 1 / 0;
  if (e === "nan" || e === "+nan" || e === "-nan")
    return NaN;
  if (e === "-0")
    return 0;
  let o;
  if ((o = Eo.test(e)) || vo.test(e)) {
    if (Ro.test(e))
      throw new V("leading zeroes are not allowed", {
        toml: s,
        ptr: i
      });
    let t = +e.replace(/_/g, "");
    if (isNaN(t))
      throw new V("invalid number", {
        toml: s,
        ptr: i
      });
    if (o && !Number.isSafeInteger(t))
      throw new V("integer value cannot be represented losslessly", {
        toml: s,
        ptr: i
      });
    return t;
  }
  let u = new $e(e);
  if (!u.isValid())
    throw new V("invalid value", {
      toml: s,
      ptr: i
    });
  return u;
}
function Ao(e, s, i, o) {
  let u = e.slice(s, i), t = u.indexOf("#");
  t > -1 && ($r(e, t), u = u.slice(0, t));
  let r = u.trimEnd();
  if (!o) {
    let n = u.indexOf(`
`, r.length);
    if (n > -1)
      throw new V("newlines are not allowed in inline tables", {
        toml: e,
        ptr: s + n
      });
  }
  return [r, t];
}
function Ar(e, s, i, o) {
  if (o === 0)
    throw new V("document contains excessively nested structures. aborting.", {
      toml: e,
      ptr: s
    });
  let u = e[s];
  if (u === "[" || u === "{") {
    let [n, a] = u === "[" ? bo(e, s, o) : So(e, s, o), c = Jn(e, a, ",", i);
    if (i === "}") {
      let l = je(e, a, c);
      if (l > -1)
        throw new V("newlines are not allowed in inline tables", {
          toml: e,
          ptr: l
        });
    }
    return [n, c];
  }
  let t;
  if (u === '"' || u === "'") {
    t = gs(e, s);
    let n = ms(e, s, t);
    if (i) {
      if (t = ge(e, t, i !== "]"), e[t] && e[t] !== "," && e[t] !== i && e[t] !== `
` && e[t] !== "\r")
        throw new V("unexpected character encountered", {
          toml: e,
          ptr: t
        });
      t += +(e[t] === ",");
    }
    return [n, t];
  }
  t = Jn(e, s, ",", i);
  let r = Ao(e, s, t - +(e[t - 1] === ","), i === "]");
  if (!r[0])
    throw new V("incomplete key-value declaration: no value specified", {
      toml: e,
      ptr: s
    });
  return i && r[1] > -1 && (t = ge(e, s + r[1]), t += +(e[t] === ",")), [
    $o(r[0], e, s),
    t
  ];
}
let wo = /^[a-zA-Z0-9-_]+[ \t]*$/;
function ar(e, s, i = "=") {
  let o = s - 1, u = [], t = e.indexOf(i, s);
  if (t < 0)
    throw new V("incomplete key-value: cannot find end of key", {
      toml: e,
      ptr: s
    });
  do {
    let r = e[s = ++o];
    if (r !== " " && r !== "	")
      if (r === '"' || r === "'") {
        if (r === e[s + 1] && r === e[s + 2])
          throw new V("multiline strings are not allowed in keys", {
            toml: e,
            ptr: s
          });
        let n = gs(e, s);
        if (n < 0)
          throw new V("unfinished string encountered", {
            toml: e,
            ptr: s
          });
        o = e.indexOf(".", n);
        let a = e.slice(n, o < 0 || o > t ? t : o), c = je(a);
        if (c > -1)
          throw new V("newlines are not allowed in keys", {
            toml: e,
            ptr: s + o + c
          });
        if (a.trimStart())
          throw new V("found extra tokens after the string part", {
            toml: e,
            ptr: n
          });
        if (t < n && (t = e.indexOf(i, n), t < 0))
          throw new V("incomplete key-value: cannot find end of key", {
            toml: e,
            ptr: s
          });
        u.push(ms(e, s, n));
      } else {
        o = e.indexOf(".", s);
        let n = e.slice(s, o < 0 || o > t ? t : o);
        if (!wo.test(n))
          throw new V("only letter, numbers, dashes and underscores are allowed in keys", {
            toml: e,
            ptr: s
          });
        u.push(n.trimEnd());
      }
  } while (o + 1 && o < t);
  return [u, ge(e, t + 1, !0, !0)];
}
function So(e, s, i) {
  let o = {}, u = /* @__PURE__ */ new Set(), t, r = 0;
  for (s++; (t = e[s++]) !== "}" && t; ) {
    if (t === `
`)
      throw new V("newlines are not allowed in inline tables", {
        toml: e,
        ptr: s - 1
      });
    if (t === "#")
      throw new V("inline tables cannot contain comments", {
        toml: e,
        ptr: s - 1
      });
    if (t === ",")
      throw new V("expected key-value, found comma", {
        toml: e,
        ptr: s - 1
      });
    if (t !== " " && t !== "	") {
      let n, a = o, c = !1, [l, h] = ar(e, s - 1);
      for (let b = 0; b < l.length; b++) {
        if (b && (a = c ? a[n] : a[n] = {}), n = l[b], (c = Object.hasOwn(a, n)) && (typeof a[n] != "object" || u.has(a[n])))
          throw new V("trying to redefine an already defined value", {
            toml: e,
            ptr: s
          });
        !c && n === "__proto__" && Object.defineProperty(a, n, { enumerable: !0, configurable: !0, writable: !0 });
      }
      if (c)
        throw new V("trying to redefine an already defined value", {
          toml: e,
          ptr: s
        });
      let [f, g] = Ar(e, h, "}", i - 1);
      u.add(f), a[n] = f, s = g, r = e[s - 1] === "," ? s - 1 : 0;
    }
  }
  if (r)
    throw new V("trailing commas are not allowed in inline tables", {
      toml: e,
      ptr: r
    });
  if (!t)
    throw new V("unfinished table encountered", {
      toml: e,
      ptr: s
    });
  return [o, s];
}
function bo(e, s, i) {
  let o = [], u;
  for (s++; (u = e[s++]) !== "]" && u; ) {
    if (u === ",")
      throw new V("expected value, found comma", {
        toml: e,
        ptr: s - 1
      });
    if (u === "#")
      s = $r(e, s);
    else if (u !== " " && u !== "	" && u !== `
` && u !== "\r") {
      let t = Ar(e, s - 1, "]", i - 1);
      o.push(t[0]), s = t[1];
    }
  }
  if (!u)
    throw new V("unfinished array encountered", {
      toml: e,
      ptr: s
    });
  return [o, s];
}
function ts(e, s, i, o) {
  let u = s, t = i, r, n = !1, a;
  for (let c = 0; c < e.length; c++) {
    if (c) {
      if (u = n ? u[r] : u[r] = {}, t = (a = t[r]).c, o === 0 && (a.t === 1 || a.t === 2))
        return null;
      if (a.t === 2) {
        let l = u.length - 1;
        u = u[l], t = t[l].c;
      }
    }
    if (r = e[c], (n = Object.hasOwn(u, r)) && t[r]?.t === 0 && t[r]?.d)
      return null;
    n || (r === "__proto__" && (Object.defineProperty(u, r, { enumerable: !0, configurable: !0, writable: !0 }), Object.defineProperty(t, r, { enumerable: !0, configurable: !0, writable: !0 })), t[r] = {
      t: c < e.length - 1 && o === 2 ? 3 : o,
      d: !1,
      i: 0,
      c: {}
    });
  }
  if (a = t[r], a.t !== o && !(o === 1 && a.t === 3) || (o === 2 && (a.d || (a.d = !0, u[r] = []), u[r].push(u = {}), a.c[a.i++] = a = { t: 1, d: !1, i: 0, c: {} }), a.d))
    return null;
  if (a.d = !0, o === 1)
    u = n ? u[r] : u[r] = {};
  else if (o === 0 && n)
    return null;
  return [r, u, a.c];
}
function Oo(e, s) {
  let i = s?.maxDepth ?? 1e3, o = {}, u = {}, t = o, r = u;
  for (let n = ge(e, 0); n < e.length; ) {
    if (e[n] === "[") {
      let a = e[++n] === "[", c = ar(e, n += +a, "]");
      if (a) {
        if (e[c[1] - 1] !== "]")
          throw new V("expected end of table declaration", {
            toml: e,
            ptr: c[1] - 1
          });
        c[1]++;
      }
      let l = ts(
        c[0],
        o,
        u,
        a ? 2 : 1
        /* Type.EXPLICIT */
      );
      if (!l)
        throw new V("trying to redefine an already defined table or value", {
          toml: e,
          ptr: n
        });
      r = l[2], t = l[1], n = c[1];
    } else {
      let a = ar(e, n), c = ts(
        a[0],
        t,
        r,
        0
        /* Type.DOTTED */
      );
      if (!c)
        throw new V("trying to redefine an already defined table or value", {
          toml: e,
          ptr: n
        });
      let l = Ar(e, a[1], void 0, i);
      c[1][c[0]] = l[0], n = l[1];
    }
    if (n = ge(e, n, !0), e[n] && e[n] !== `
` && e[n] !== "\r")
      throw new V("each key-value declaration must be followed by an end-of-line", {
        toml: e,
        ptr: n
      });
    n = ge(e, n);
  }
  return o;
}
const _o = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  TomlDate: $e,
  TomlError: V,
  parse: Oo
}, Symbol.toStringTag, { value: "Module" }));
